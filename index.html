<!DOCTYPE html>
<html lang='en'>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=9" />
  <link rel="shortcut icon" href="assets/favicon.ico" type="image/x-icon">
  <!-- Primary Meta Tags -->
  <title>Adonis Web Wallet</title>
  <meta name="title" content="Adonis Web Wallet">
  <meta name="description" content="The wallet of the future - Receive, Send, Stake and Exchange using a completely decentralized, open-source, battle-hardened ADONIS wallet.">
  <meta name="keywords" content="web,wallet,webwallet,crypto,cryptocurrency,opensource,oss,adonis,staking,masternodes,exchange,swap,decentralized">

  <meta name="mobile-web-app-capable" content="yes">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:locale" content="en_GB">
  <meta property="og:url" content="https://wallet.adonis.exchange/">
  <meta property="og:title" content="Adonis Web Wallet">
  <meta property="og:description" content="The wallet of the future - Receive, Send, Stake and Exchange using a completely decentralized, open-source, battle-hardened ADONIS wallet.">
  <meta property="og:image" content="https://wallet.adonis.exchange/assets/logo_opaque-dark-bg.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://wallet.adonis.exchange/">
  <meta property="twitter:title" content="Adonis Web Wallet">
  <meta property="twitter:description" content="The wallet of the future - Receive, Send, Stake and Exchange using a completely decentralized, open-source, battle-hardened ADONIS wallet.">
  <meta property="twitter:image" content="https://wallet.adonis.exchange/assets/logo_opaque-dark-bg.png">

  <!-- Colour Theme -->
  <meta name="msapplication-TileColor" content="#022d62">
  <meta name="theme-color" content="#022d62">

  <link rel="icon" type="image/png" href="https://wallet.adonis.exchange/assets/logo_opaque-dark-bg.png">
  <link rel="canonical" href="https://wallet.adonis.exchange/">

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="assets/bootstrap-4.5.0/css/bootstrap.min.css">
  <link href="assets/fontawesome/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="assets/style/style.css">
  <script type="text/javascript" src="assets/bootstrap-4.5.0/js/jquery.js"></script>
  <script type="text/javascript" src="assets/bootstrap-4.5.0/js/bootstrap.js"></script>
  <script type="text/javascript" src="scripts/libs/jdenticon.min.js"></script>
  <script>
    // TRANSLATION

    // We use this function to parse the UA lang in a safer way: for example, there's multiple `en` definitions
    // ... but we shouldn't duplicate the language files, we can instead cut the affix (US, GB) and simply use 'en'.
    // ... This logic may apply to other languages with such subsets as well, so take care of them here!
    const arrLangsWithSubset = ['en'];
    function parseUserAgentLang(strUA) {
      if (arrLangsWithSubset.some(strLang => strUA.includes(strLang))) {
        // Split the lang in to 'primary' and 'subset', only use the primary lang
        return strUA.substring(0, 2);
      }
      // Otherwise, just use the full language spec
      return strUA;
    }

    const strLang = parseUserAgentLang(window.navigator.userLanguage || window.navigator.language);

    //When adding a lang remember to add it to the object translatableLanguages as well as here.
    //When removing you do not have to remove from translatableLanguages
    const arrActiveLangs = ['en', 'uwu'];

    //Due to the need to switch language we need to load all the languages and then set the active one to the translation variable
    for(i=0; i<arrActiveLangs.length; i++){
      document.write('\x3Cscript src="locale/' + arrActiveLangs[i] + '/translation.js">\x3C/script>')
    }
  </script>


  <!--- IMPORTANT: CHAIN PARAMS BELOW, DO NOT EDIT UNLESS YOU'RE ABSOLUTELY CERTAIN YOU KNOW WHAT YOU'RE DOING  --->
  <script>
      // In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.
      // These below params share the same names as the CPP params, so finding and editing these is easy-peasy!
      // <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>
      const PRIVKEY_BYTE_LENGTH = 38;

      const COIN_DECIMALS = 8;
      const COIN = 10**8;

      /** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */
      const MAX_ACCOUNT_GAP = 20;
      
      /* Internal tweaking parameters */
      // A new encryption password must be 'at least' this long.
      const MIN_PASS_LENGTH = 6;

      // Cool stuff
      const donationAddress = "AcMs8uNQPgt7KErZCVfUe7TP34tjrZhWbj";

      /* chainparams */
      const cChainParams = {
          current: null,
          main: {
              collateralInSats   : 100000 * COIN,
              isTestnet         : false,
              TICKER            : "ADON",
              PUBKEY_PREFIX     : ["A"],
              STAKING_PREFIX    : "S",
              PUBKEY_ADDRESS    : 23,
              SECRET_KEY        : 212,
              BIP44_TYPE        : 638,
              BIP44_TYPE_LEDGER : 77,
	      MASTERNODE_PORT   : 31148,
              // A list of Labs-trusted explorers
              Explorers         : [
                  // Display name      Blockbook-compatible API base
                  { name: "ADON Node Main",   url: "https://mainnet.adonis.exchange" }
              ],
	      Nodes: [
		  { name: "ADON Node Main", url: "https://mainnet.adonis.exchange"}
	      ],
	      Consensus         : {
                  // Network upgrades
                  UPGRADE_V6_0  : undefined
              },
          },
          testnet: {
	      collateralInSats   : 100000 * COIN,
              isTestnet         : true,
              TICKER            : "tADON",
              PUBKEY_PREFIX     : ["a"],
              STAKING_PREFIX    : "W",
              PUBKEY_ADDRESS    : 83,
              SECRET_KEY        : 239,
              BIP44_TYPE        : 1,
              BIP44_TYPE_LEDGER : 1,
	      MASTERNODE_PORT   : 51474,
              // A list of Labs-trusted explorers
              Explorers         : [
                  // Display name      Blockbook-compatible API base
                  { name: "ADON Node Testnet",   url: "https://testnet.adonis.exchange" }
              ],
	      Nodes: [
		  { name: "ADON Node Testnet", url: "https://testnet.adonis.exchange"}
	      ],
	      Consensus         : {
                  // Network upgrades
                  UPGRADE_V6_0  : undefined
              },
          }
      }
      // Set default chain
      cChainParams.current = cChainParams.main;

  </script>
</head>

<body>
  <div id="page-container" class="home-hero">
    <div id="content-wrap">

      <!-- NAVBAR -->
      <nav class="navbar navbar-expand-lg sticky-top navbar-dark navbarSpecial">
        <div class="container">
          <img onclick="playMusic()" class="nav-logo navbar-brand noselect" src='assets/logo.png' alt="ADONIS">
          <button id="navbarToggler" class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse noselect" id="navbarNav">

            <!-- MAIN NAVBAR -->
            <ul class="navbar-nav mr-auto ptr">
              <li class="nav-item"><a id='start' class="nav-link tablinks" onclick="openTab(event, 'home')" data-i18n="navIntro">Intro</a></li>
              <li class="nav-item"><a class="nav-link tablinks" onclick="openTab(event, 'keypair')" data-i18n="navDashboard">Dashboard</a></li>
              <li class="nav-item"><a id="txTab" class="nav-link tablinks" onclick="openTab(event, 'Transaction')" data-i18n="navSend">Send</a></li>
              <li class="nav-item"><a id="stakeTab" class="nav-link tablinks" onclick="openTab(event, 'StakingTab')" data-i18n="navStake">Stake</a></li>
              <li class="nav-item"><a id="masternodeTab" class="nav-link tablinks" onclick="openTab(event, 'Masternode')" data-i18n="navMasternode">Masternode</a></li>
              <li class="nav-item"><a id="governanceTab" class="nav-link tablinks" onclick="openTab(event, 'Governance')" data-i18n="navGovernance">Governance</a></li>
              <li class="nav-item"><a class="nav-link tablinks" onclick="openTab(event, 'Settings');" data-i18n="navSettings">Settings</a></li>

            </ul>

            <!-- SIDE NAVBAR -->
            <div class="form-inline my-2 my-lg-0">
              <ul class="navbar-nav mr-auto ptr">
                <li class="nav-item"><a class="nav-link tablinks active" id="Testnet" onclick="toggleTestnet()" data-i18n="navTestnet"><b>Testnet Mode On</b></a></li>
                <li class="nav-item"><a class="nav-link tablinks active" id="Network" onclick="toggleNetwork()"><span data-i18n="navNetwork">Network:</span> <span id="NetworkE" data-i18n="enabled">Enabled</span><span id="NetworkD" data-i18n="disabled">Disabled</span></a></li>
                <li class="nav-item"><a class="nav-link tablinks active" id="Debug" onclick="toggleDebug()"><b>DEBUG MODE ON</b></a></li>
              </ul>
            </div>
          </div>
        </div>
      </nav>
      <!-- // NAVBAR -->


      <!-- // WARNING MESSAGE -->
      <div class="warning-message" id='outdated'>
        <div class="container">
          <p>WARNING: your version is outdated,
          please update to the newest stable version at the <a href='https://github.com/adonisexchange/Adon-Web-Wallet/releases'>Adonis Web Wallet Github</a>
          </p>
        </div>
      </div>
      <!-- // WARNING MESSAGE -->


      <!-- // QR MODAL -->
      <div class="modal fade" id="qrModal" tabindex="-1" role="dialog" aria-labelledby="qrModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="qrModalLabel">Address QR</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body center-text">
              <p id="ModalQRLabel" class="modal-label"></p>
              <div id="ModalQR" class="auto-fit"></div>
            </div>
          </div>
        </div>
      </div>
      <br>
      <!-- // MNEMONIC MODAL -->
      <div class="modal fade" id="mnemonicModal" tabindex="-1" role="dialog" aria-labelledby="qrModalLabel" aria-hidden="true" data-backdrop="static" data-keyboard="false">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-body center-text">
              <p id="ModalMnemonicLabel" class="modal-label"></p>
              <div id="ModalMnemonic" class="auto-fit">
                This is your seed phrase:
                <b>
                  <div class="seed-phrase noselect" id="ModalMnemonicContent">
                    <!-- Test1 Test2 Test1 Test2 Test1 Test2 Test1 Test2 Test1 Test2 Test1 Test2 -->
                  </div>
                </b>
                <br>
                Write it down somewhere. You'll only see this <b>once!</b>
                <br>
                Anyone with a copy of it can access <b>all</b> of your funds.
                <br>
                <b>Do NOT share it with anybody</b>.
                <br><br>
                <a href="https://www.ledger.com/blog/how-to-protect-your-seed-phrase" target="_blank"><i>It is <b>NOT</b> advised to store this digitally.</i></a>
                <br><br>
              </div>
	      <div class="modal-footer">
		  <button type="button" id="modalMnemonicConfirmButton" class="adonis-button-big">I have written down my seed phrase</button>
	      </div>
            </div>
          </div>
        </div>
      </div>
    <br>
      <!-- // CONFIRM MODAL -->
    <div class="modal" id="confirmModal" tabindex="-1" role="dialog" aria-hidden="true" data-backdrop="static" data-keyboard="false">
        <div class="modal-dialog modal-dialog-centered" role="document" style="max-width: 600px">
          <div class="modal-content">
            <div class="modal-header" id="confirmModalHeader">
              <h3 class="modal-title" id="confirmModalTitle" style="text-align: center;width: 100%;color: #8e21ff;">Insert cool popup title</h3>
            </div>
            <div id="confirmModalContent" class="modal-body center-text">
              <!-- JS populated modal content -->
            </div>
            <div class="modal-footer" hidden="true" id="confirmModalButtons">
              <button type="button" id="confirmModalConfirmButton" class="adonis-button-big" style="float: right">Confirm</button>
              <button type="button" id="confirmModalCancelButton" class="adonis-button-big" style="float: right; opacity: 0.7;">Cancel</button>
            </div>
          </div>
        </div>
      </div>


      <div class="container">
        <div class="row no-gutters">
          <div class='col-md-12 rm-pd'>
            <div id="home" class="tabcontent">

              <!-- ADONIS TITLE SECTION -->
              <div class="col-md-12 title-section float-left rm-pd">
                  <h1 class="adonis-bold-title center-text"><span data-i18n="title">Welcome to</span> <div data-i18n="titleName">Adonis Web Wallet</div></h1>
              </div>
              <!-- // ADONIS TITLE SECTION -->

              <!-- ADONIS FEATURE SECTION -->
              <div class="col-md-12 features-section float-left rm-pd intro-page">

                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_governance.png" alt="ADONIS Governance">
                    </div>

                    <h4 data-i18n="cardOneTitle">Be your own Bank!</h4>
                    <h5 data-i18n="cardOneDesc">
                      AWW has <b>no custody</b> over your funds. You are in full ownership of your keys and your ADON.
                    </h5>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->

                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_pos.png" alt="ADONIS Proof of Stake (PoS)">
                    </div>

                    <h4 data-i18n="cardTwoTitle">Universal and Portable</h4>
                    <h5 data-i18n="cardTwoDesc">
                      You can generate cryptographically-secure addresses with your browser and hardware.
                    </h5>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->

                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_privacy.png" alt="ADONIS Privacy" class="smaller-feature">
                    </div>

                    <h4 data-i18n="cardThreeTitle">Don't trust, verify!</h4>
                    <h5 data-i18n="cardThreeDesc">
                      AWW is completely open-source, available on the Adonis Network github.
                    </h5>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->

                
                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_slider_bars.png" alt="ADONIS Bar Chart" class="smaller-feature">
                    </div>

                    <h4 data-i18n="cardFourTitle">For the community</h4>
                    <h5 data-i18n="cardFourDesc">
                      AWW is built with love without any fees, privacy intrusions or advertising.
                    </h5>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->

                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_windows.png" alt="ADONIS Windows" class="smaller-feature">
                    </div>

                    <h4 data-i18n="cardFiveTitle">Download Windows Core Wallet</h4>
                    <h5 data-i18n="cardFiveDesc">
                      Dowload Latest stable release Windows Wallet.
                    </h5>
                    <span onclick="window.location.href='https://github.com/AdonisExchange/ADON/releases/download/v5.5.0.1/adon-5.5.0.1-win64-setup-unsigned.exe'" class="purple-icon-link ptr">
                      <span data-i18n="cardFiveLink">Download</span><span class="link-icon link-icon-suffix"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </span>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->

                <!-- ADONIS FEATURE -->
                <div class="col-md-6 float-left adonis-feature-father">
                  <div class="col-md-11 adonis-feature-interior">

                    <div class="col-md-12 feature-icon">
                      <img src="assets/img_mac.png" alt="ADONIS MAC" class="smaller-feature">
                    </div>

                    <h4 data-i18n="cardSixTitle">Download MacOS Core Wallet</h4>
                    <h5 data-i18n="cardSixDesc">
                      Download the Latest stable release MacOS Wallet. 
                    </h5>
                    <span onclick="window.location.href='https://github.com/AdonisExchange/ADON/releases/download/v5.5.0.1/ADON-Core.dmg'" class="purple-icon-link ptr">
                      <span data-i18n="cardSixLink">Download</span><span class="link-icon link-icon-suffix"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </span>
                  </div>
                </div>
                <!-- // ADONIS FEATURE -->
              </div>
              <!-- // ADONIS FEATURE SECTION -->

              <!-- ADONIS DONATION SECTION -->
              <div class="col-md-12 donation-section float-left rm-pd text-center">
                  <button class="adonis-button-big" onclick="guiPreparePayment(donationAddress)">
                            <span class="buttoni-icon"></span>
                            <span class="buttoni-text" data-i18n="buttonDonate">Donate - Pay with Adonis Web Wallet</span>
                            <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                  </button>

              </div>
              <!-- // ADONIS DONATION SECTION -->

            </div>


            <!-- KEYPAIR SECTION -->
            <div id="keypair" class="tabcontent">

              <!-- ADONIS TITLE SECTION -->
              <div class="col-md-12 title-section rm-pd">
                  <h3 class="adonis-bold-title center-text" data-i18n="dashboardTitle">Dashboard</h3>
              </div>
              <!-- // ADONIS TITLE SECTION -->



              <!-- GENERATE WALLET -->
              <div id='generateWallet' class="dashboard-item">
                <div class="container">



                  <div class="col-md-12 dashboard-title">
                    <h3 class="adonis-bold-title-smaller"><span data-i18n="dCardOneTitle">Create a</span> <div data-i18n="dCardOneSubTitle">New Wallet</div></h3>
                    <p data-i18n="dCardOneDesc">This will create a new, random ADONIS wallet that will contain no initial funds, you may transfer to-and-from this wallet with ease.</p>
                  </div>


                  <button class="adonis-button-big" onclick="generateWallet()">
                              <span class="buttoni-icon"></span>
                              <span class="buttoni-text" data-i18n="dCardOneButton">Create A New Wallet</span>
                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </button>
                </div>
              </div>
              <!-- // GENERATE WALLET -->
              <br>

              <!-- WALLET FUNCTIONALITIES -->

              <!-- WARNING -->
             <div id='genKeyWarning' style='display: none;' class="alert alert-danger col-md-12" role="alert">
                <div style="max-width: 100% !important;">
                  <p id="encryptWarningText" class="center-text">
                    <b>WARNING</b><br>
                    If you don't save your private key you will lose access to your funds!<br>
                    Would you like to encrypt & save your wallet in your browser?
                  </p>
                </div>
                <div id="encryptPassword" style="display: none !important; max-width: 100% !important; max-width: 100% !important;">
                  <input class="center-text" style="width: 100%; font-family: monospace;" type="password" id="newPassword" placeholder="Enter Password">
                  <input class="center-text" style="width: 100%; font-family: monospace;" type="password" id="newPasswordRetype" placeholder="Re-type Password">
                </div>
                  <button class="adonis-button-big" onclick="guiEncryptWallet()" style="float: none;margin: 0 auto;display: block;">
                    <span class="buttoni-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M85.967 10.65l-32.15-9.481a13.466 13.466 0 00-7.632 0l-32.15 9.48C11.661 11.351 10 13.567 10 16.042v26.623c0 12.321 3.67 24.186 10.609 34.31 6.774 9.885 16.204 17.49 27.264 21.99a5.612 5.612 0 004.251 0c11.061-4.5 20.491-12.104 27.266-21.99C86.329 66.85 90 54.985 90 42.664V16.042a5.656 5.656 0 00-4.033-5.392zM69 68.522C69 70.907 67.03 72 64.584 72H34.092C31.646 72 30 70.907 30 68.522v-23.49C30 42.647 31.646 41 34.092 41H37v-9.828C37 24.524 41.354 18.5 49.406 18.5 57.37 18.5 62 24.066 62 31.172V41h2.584C67.03 41 69 42.647 69 45.032v23.49zM58 41v-9.828c0-4.671-3.708-8.472-8.5-8.472-4.791 0-8.5 3.8-8.5 8.472V41h17z"></path></svg></span>
                    <span class="buttoni-text" id="encryptButton">Set Password</span>
                    <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                  </button>
              </div>
              <!-- // WARNING -->
              <br>

              <!-- WALLET FEATURES -->
              <div id="guiWallet" style="display: none;">
                <div id="bcg-wallet-box">
                    <div id="headline-balance">
                        <div id="balance-box" class="large-box">
                            <div id="window-icon-adon">
                                <div id="adon-ring"></div>
                                <div id="number-adon">
                                    <p id="guiBalanceBox"><b id="guiBalance">~</b> <span id="guiBalanceTicker">ADON</span></p>
                                </div>
                            </div>
                            <div id="bal-title">
                                <h3 class="noselect balance-title">Balance &nbsp;&nbsp;<span id="balanceReload" class="reload noselect" onclick="refreshChainData()">&#x21bb;</span></h3>
                            </div>
                        </div>
                    </div>
                      <!-- WALLET FEATURE -->
                    <div id="big-frame-address">
                        <div id="address-box" class="large-box">
                            <div id="title-address-box">
                                <h3 class="noselect addr-title">Address</h3>
                            </div>
                            <div id="box-info-address">
                                <div id="ring">
                                    <canvas id="identicon" class="innerShadow" width="65" height="65" data-jdenticon-value=""></canvas>
                                </div>
                                <div id="address-info">
                                    <b id="guiAddress">~</b>
                                    <b id="guiQRButton">
                                      <i data-toggle="modal" data-target="#qrModal" class="fas fa-qrcode fa-stacked-ptr"></i>
                                      <i id="guiNewAddress" onclick="getNewAddress({updateGUI: true, verify: true})" class="fas fa-sync fa-stacked-ptr"></i>
                                      <i onclick="toClipboard('guiAddress', this)" id="guiAddressCopy" class="fas fa-clipboard fa-stacked-ptr"></i>
                                      <i id="guiExportWallet" onclick="toggleExportUI()" class="fas fa-share fa-stacked-ptr"></i>
                                    </b>
                                </div>
                            </div>
                          <div id="exportKeyDiv" hidden="true">
                            Your private key:
                            <div class="export-key private-key-area" id="exportKeyText"> </div>
                          </div>
                        </div>
                    </div>
                </div>
              </div>
              <!-- WALLET FEATURES -->

              <!-- // WALLET FUNCTIONALITIES -->

              <!-- GENERATE VANITY WALLET -->
              <div id='generateVanityWallet' class="dashboard-item">
                <div class="container">

                  <div class="col-md-12 dashboard-title">
                    <h3 class="adonis-bold-title" style="font-size:38px;"><span data-i18n="dCardTwoTitle" >Create a new</span> <div data-i18n="dCardTwoSubTitle">Vanity Wallet</div></h3>
                    <span class="badge badge-warning" data-i18n="experimental" >Experimental</span>
                    <p data-i18n="dCardTwoDesc">This will create a ADONIS wallet with a customized prefix of your choosing, requiring more processing power to generate such addresses, it is recommended to generate a prefix of less than 6 characters, for example: "DAD" is a possible address prefix.</p>
                    <span style="opacity: 0.75; font-size: small;">*Note: Generated addresses will automatically be preceded by the network prefix: <b id='prefixNetwork'></b></span></p>
                  </div>


                  <input class="center-text" style="display:none;" type="text" id='prefix' placeholder="Address Prefix" onkeypress="checkVanity()">

                  <button class="adonis-button-big" onclick="generateVanityWallet()">
                              <span class="buttoni-icon"></span>

                              <span class="buttoni-text" id="vanButtonText" data-i18n="dCardTwoButton" >Create A Vanity Wallet</span>

                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </button>
                </div>
              </div>
              <!-- // GENERATE VANITY WALLET -->
              <br>

              <!-- ACCESS LEDGER HARDWARE WALLET -->
              <div id='generateHardwareWallet' class="dashboard-item">
                <div class="container">

                  <div class="col-md-12 dashboard-title">
                    <h3 class="adonis-bold-title" style="font-size:38px;"><span data-i18n="dCardThreeTitle">Access your</span><div data-i18n="dCardThreeSubTitle">Hardware Wallet</div></h3>
                    <p data-i18n="dCardThreeDesc">This will help managing the ADONIS wallet on your ledger. Notice that the private key will remain safe in your hardware device</p>
                  </div>

                  <button class="adonis-button-big" onclick="importWallet({isHardwareWallet: true})">

                    <span class="buttoni-text" data-i18n="dCardThreeButton">Access my hardware wallet</span>

                    <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
                        <path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path>
                      </svg></span>
                  </button>
                </div>
              </div>
              <!-- // IMPORT LEDGER HARDWARE WALLET -->
              <br>

              <!-- ACCESS WALLET -->
              <div id="accessWallet" class="dashboard-item" style="margin-bottom:100px;">
                <div class="container">

                  <div class="col-md-12 dashboard-title">
                    <h3 class="adonis-bold-title-smaller"><span data-i18n="dCardFourTitle">Go to</span> <div data-i18n="dCardFourSubTitle">My Wallet</div></h3>
                    <p data-i18n="dCardFourDesc">This will import a ADONIS wallet that you hold via it's private key, loading the address and pulling your existing balance, if any, from an explorer node.
                      <br>
                      <span style="opacity: 0.75; font-size: small;" data-i18n="dCardFourSubDesc">*Note: AWW developers can NOT access your wallet, this wallet runs purely in YOUR browser using JavaScript.</span>
                    </p>
                  </div>

                  <!-- IMPORT WALLET -->
                  <input class="hide-element" type="text" id="clipboard">
                  <div id='importWallet' style='display: none;'>
                    <input type="password" id='privateKey' placeholder="Seed Phrase, XPriv or WIF Private Key" oninput="onPrivateKeyChanged()">
                    <input hidden type="password" id='privateKeyPassword' placeholder="Password">
                    <button class="adonis-button-big" onclick="guiImportWallet()">
                                  <span class="buttoni-icon"><i class="fas fa-file-upload fa-tiny-margin"></i></span>
                                  <span class="buttoni-text" id="importWalletText" data-i18n="dCardFourButtonI" >Import Wallet</span>
                                  <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                        </button>
                  </div>
                  <!-- // IMPORT WALLET -->

                  <button class="adonis-button-big" id="accessWalletBtn" onclick="accessOrImportWallet()">
                              <span class="buttoni-icon"></span>

                              <span class="buttoni-text" id='wToggle' data-i18n="dCardFourButtonA">Access My Wallet</span>

                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </button>
                </div>
              </div>
              <!-- // ACESSS WALLET -->
              <br>


              <br>

            </div>
            <!-- // KEYPAIR SECTION -->

            <div id="StakingTab" class="tabcontent">
              <!-- STAKING FEATURES -->
              <p id="info" class="minor-notif-subtext"><span data-i18n="stakeTitle"><b>New Feature!</b></span><br><span data-i18n="stakeSubTitle">Please be aware AWW Cold Staking is a new, slightly experimental feature, it may be unstable, and is currently slow. Please have patience when using this feature, and wait for block confirmations before actions and balances are shown on-screen.</span></p>
              <div class="add-frame">
              <div class="staking-banner-top">
                <div id="staking-rectangle" class="col-md-4">
                    <div id="adonis-price-box">
                        <div id="icon-box-adon">
                            <div id="adon-price" class="staking-adon-icon"></div>
                        </div>
                        <div id="adon-price-amount">
                            <p id="guiBalanceBoxStaking"><b id="guiBalanceStaking">~</b> <span id="guiBalanceStakingTicker">ADON</span></p>
                        </div>
                    </div>
                    <div id="staking-box">
                      <h3 id="stake-title" class="noselect"><span data-i18n="staking">Staking</span> &nbsp;&nbsp;<span id="balanceReloadStaking" class="reload noselect" onclick="refreshChainData()">&#x21bb;</span></h3>
                    </div>
                </div>
              </div>
              <br>
              <div class="staking-banner-bottom">
                <div class="stake-box large-box col-md-4">
                  <h5 id="availToDelegate" onclick="selectMaxBalance(domGuiDelegateAmount)" class="stake-balances ptr"><span data-i18n="available">Available</span>: 0 ADON</h5>
                  <textarea id="delegateAmount" class="stake-input form-control private-key-area"></textarea>
                  <div class="button-padd">
                      <button class="adonis-button-big" onclick="delegateGUI()">
                                  <span class="buttoni-icon"><i class="far fa-snowflake fa-tiny-margin"></i></span>
                                  <span class="buttoni-text" data-i18n="staking">Stake</span>
                                  <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                        </button>
                 </div>
                </div>
                <div class="stake-box large-box col-md-4">
                  <h5 id="availToUndelegate" onclick="selectMaxBalance(domGuiUndelegateAmount, true)" class="stake-balances ptr"><span data-i18n="staking">Staking</span>: 0 ADON</h5>
                  <textarea id="undelegateAmount" class="stake-input form-control private-key-area"></textarea>
                  <div class="button-padd">
                      <button class="adonis-button-big" onclick="undelegateGUI()">
                                  <span class="buttoni-icon"><i class="far fa-snowflake fa-tiny-margin"></i></span>
                                  <span class="buttoni-text" data-i18n="stakeUnstake">Unstake</span>
                                  <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                        </button>
                 </div>
                </div>
              </div>
              <!-- STAKING FEATURES -->
              <div class="staking-banner-bottom">
                <div class="stake-box large-box col-md-4">
                  <div id="staking-rewards-title" class="staking-rewards-header">
                    <h5> <span data-i18n="staking">Staking</span> <span data-i18n="rewards">Rewards</span> </h5>
                  </div>
                  <div class="staking-rewards-list">
                <div id="staking-rewards-content">
              </div>
              <button type="button" id="stakingLoadMore" onclick="getStakingRewards()">
                <span class="buttoni-icon" id="stakingLoadMoreIcon"><i class="fas fa-sync fa-tiny-margin"></i></span>
                <span class="buttoni-text" data-i18n="stakeLoadMore">Load more</span>
              </button>
            </div>
          </div>
	      </div>
	    </div>
    </div>
          <div id="Governance" class="tabcontent">
              <div class="col-md-12 title-section float-left rm-pd">
                <h3 class="adonis-bold-title center-text"> Governance</h3>
                <p class="center-text">From this tab you can check the proposals and, if you have a masternode, be a part of the <b>DAO</b> and vote!</p>
              </div>
              <table id="proposalsTable" class="table table-hover table-dark bg-transparent" style="width:100%">
		  <thead>
		      <td class="text-center"> <b> Name </b> </td>
		      <td class="text-center"> <b> Payment </b> </td>
		      <td class="text-center"> <b> Votes </b> </td>
		      <td class="text-center"> <b> Vote </b> </td>
		  </thead>
		  <tbody id="proposalsTableBody" style="text-align: center; vertical-align: middle;">
		  </tbody>
              </table>
          </div>
          <div id="Masternode" class="tabcontent">
            <div class="col-md-12 title-section float-left rm-pd">
              <h3 class="adonis-bold-title center-text"><span>Control your</span> Masternode</h3>
              <p class="center-text">From this tab you can create and access one or more masternodes</p>
            </div>
         
            <div style='display: block;'>
              <br>
              <p id="mnTextErrors" class="center-text"></p>
            </div>

            <!-- IMPORT MASTERNODE -->
            <div id='accessMasternode' class="dashboard-item" style='display:none; width:100%;'>
              <div class="container">

                <div id="accessMasternodeText"></div> 
                <br>
                <input class="hide-element" type="text">
                <div style='display: block;'>
                  <input type="password" id='mnPrivateKey' placeholder="Masternode Private Key">
                  <input type="text" id='mnIP' placeholder="Masternode ip address">
                  <select id='mnTxId' style="display: block;" placeholder="Masternode collateral tx" class="form-control">
		  </select>
                  <button class="adonis-button-big" onclick="importMasternode()">
                                <span class="buttoni-icon"><i class="fas fa-file-upload fa-tiny-margin"></i></span>
                                <span class="buttoni-text" id="importMnText">Access Masternode</span>
                                <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                      </button>
                </div>
              </div>
            </div>
            <!-- // IMPORT MASTERNODE -->
            <br>            

            <div id='createMasternode' class="dashboard-item" style='display:none; width:100%;'>
              <div class="container" >

                <h4>Create a masternode <small style="opacity: 0.75;">(10k ADON)</small></h4> 
                <input class="hide-element" type="text">
                <div style='display: block;'>
                  <p>Choose your Masternode type</p>
                  <select id='mnCreateType' style="display: block; text-align: center;" placeholder="Masternode collateral tx" class="form-control">
		                <option value="VPS"> Self-hosted (a masternode server ran by you)</option>
                    <option value="Third Party"> Third Party (a masternode server ran by someone else)</option>
                  </select>
                  <br>
                  <br>
                  <button class="adonis-button-big" onclick="createMasternode()">
                                <span class="buttoni-icon"><i class="fas fa-file-upload fa-tiny-margin"></i></span>
                                <span class="buttoni-text" id="importMnText">Create Masternode</span>
                                <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                      </button>
                </div>
              </div>
            </div>

            <div id="mnDashboard" class="staking-banner-bottom">
              <div class="stake-box large-box col-md-4">
                <h4 class="stake-balances" style="background-color: #2c0044;border-radius: 10px;">
                  Status <small id="mnProtocol" style="opacity: 0.5;"></small>
                </h4>
                <h2 id="mnStatus" class="stake-balances" style="overflow-wrap: anywhere;top: 50%;left: 50%;transform: translate(-50%, -50%);position: absolute;width: 100%;padding: 10px;" id="mnStatus">
                  
                </h2>
              </div>
              <div class="stake-box large-box col-md-4">
                <h4 id="mnNetType" class="stake-balances" style="background-color: #2c0044;border-radius: 10px;">
                  
                </h4>
                <h2 id="mnNetIP" class="stake-balances" style="overflow-wrap: anywhere;top: 50%;left: 50%;transform: translate(-50%, -50%);position: absolute;width: 100%;padding: 10px;font-family: mono !important;font-size: x-large;" id="mnStatus">
                  
                </h2>
              </div>
              <div class="stake-box large-box col-md-4">
                <h4 class="stake-balances" style="background-color: #2c0044;border-radius: 10px;">
                  Last Seen
                </h4>
                <h2 id="mnLastSeen" class="stake-balances" style="overflow-wrap: anywhere;top: 50%;left: 50%;transform: translate(-50%, -50%);position: absolute;width: 100%;padding: 10px;font-size: xx-large;" id="mnStatus">
                  
                </h2>
              </div>
            </div>

            <br>

            <center id='controlMasternode' style='display:none; width:100%;'>
                <button class="adonis-button-big" onclick="destroyMasternode()" style="margin: 20px; font-weight: 550 !important;">
                  <span class="buttoni-icon"><i class="fas fa-burn fa-tiny-margin"></i></span>
                  <span class="buttoni-text" id="importMnText">Destroy Masternode</span>
                </button>

                <button class="adonis-button-big" onclick="startMasternode(true)" style="margin: 20px; font-weight: 550 !important;">
                  <span class="buttoni-icon"><i class="fas fa-redo-alt fa-tiny-margin"></i></span>
                  <span class="buttoni-text" id="importMnText">Restart Masternode</span>
                </button>
            </center>

          </div>

            <div id="Transaction" class="tabcontent">

              <!-- ADONIS TITLE SECTION -->
              <div class="col-md-12 title-section float-left rm-pd">
                  <h3 class="adonis-bold-title center-text"><span data-i18n="sendTitle">Create a</span> <div data-i18n="sendSubTitle">Transaction</div></h3>
              </div>
              <br>
              <!-- // ADONIS TITLE SECTION -->

              <div id='sendNotice' class="col-md-12 float-left"></div>
              <div class="col-md-12">
                <p id="communication" class="center-text" data-i18n="sendShieldingWarning">Please <b>AVOID</b> sending to Shielded addresses using this wallet - this functionality is currently unsupported.</p>
              </div>
              <div class='max-width' style='clear:both;'>
                <div id="simpleTransactionsDropdown" class="bold-trans" onclick='toggleDropDown("simpleTransactions")'><div data-i18n="sendSimpleTxTitle">Create Simple Transactions</div><span
                    style='float:right;'>▼</span></div>
                <div id='simpleTransactions' style='display: block'>
                  <br>
                  <label data-i18n="sendSimpleTxAddress">Address</label><br>
                  <input class="center-text" style="width: 100%; font-family: monospace;" type="text" id="address1s">
                  <br>
                  <label><span data-i18n="amount">Amount</span> | <b onclick="selectMaxBalance(domValue1s)" style="opacity: 0.8;" class="ptr" data-i18n="sendSimpleTxAll">(Send All)</b></label><br>
                  <input class="center-text" type="text" id="value1s">
                  <div id="reqDescDisplay" style="display: none;">
                    <label data-i18n="sendSimpleTxDesc">Description (from the merchant)</label><br>
                    <input class="center-text" type="text" disabled id="reqDesc">
                  </div>
                  <br>
                  <div id='HumanReadable'></div>
                  <br>
                  <button class="adonis-button-big" onclick="createTxGUI()">
                              <span class="buttoni-icon"><i class="fas fa-paper-plane fa-tiny-margin"></i></span>
                              <span class="buttoni-text" id="genIt" data-i18n="sendSimpleTxButton">Send Transaction</span>
                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </button>
                </div>
                <div id='transactionFinal'></div>
              </div>
              <br>
              <div class='max-width' style='clear:both;'>
                <div onclick='toggleDropDown("advTransactions")' class="bold-trans"><div data-i18n="sendManualTxTitle">Manual Transactions</div><span
                    style='float:right;'>▼</span></div>
                <div id='advTransactions' style='display:none'>
                  <br>
                  <h3 data-i18n="sendManualTxInput">Inputs</h3>
                  <label data-i18n="sendManualTxTRXHash">Trx Hash</label><br>
                  <input type="text" id="prevTrxHash">
                  <label data-i18n="sendManualTxIndex">Index</label><br>
                  <input type="text" id="index">
                  <label data-i18n="sendManualTxScript">Script</label><br>
                  <input type="text" id="script"><br><br>
                  <h3 data-i18n="sendManualTxOutputs">Outputs</h3>
                  <label data-i18n="sendManualTxOutputAddr">Output Address 1</label><br>
                  <input type="text" id="address1">
                  <label data-i18n="amount">Amount</label><br>
                  <input type="text" id="value1">
                  <br />
                  <label data-i18n="sendManualTxOutputAddrTwo">Output address 2</label><br>
                  <input type="text" id="address2">
                  <label data-i18n="amount">Amount</label><br>
                  <input type="text" id="value2"><br><br>
                  <h3 data-i18n="sendManualTxWIFKey">WIF Key</h3>
                  <input type="text" id="wif">
                  <br /><br />
                  <p style="padding: 5px 0 15px;" data-i18n="sendManualTxWarning"><b>WARNING:</b> ANY FUNDS NOT ALLOCATED WILL BE USED AS FEES</p>
                  <button class="adonis-button-big" onclick="createRawTransaction()">
                              <span class="buttoni-icon"><i class="fas fa-paper-plane fa-tiny-margin"></i></span>
                              <span class="buttoni-text" data-i18n="sendManualTxButton">Create Raw Signed Transction</span>
                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
                    </button>
                  <br /><br /><br />
                  <h4 id="signed-raw" data-i18n="sendSignedRawTx">Signed Raw Transaction</h4>
                  <textarea rows="15" cols="70" id="rawTrx"></textarea>
                  <p><span data-i18n="sendSignedTutorial">Don't understand how this works?</span> <a target='_blank'
                      href='https://github.com/adonisexchange/Adon-Web-Wallet#transaction'><span data-i18n="sendSignedTutorialLink">Tutorial Here</span></a></p>
                  <p data-i18n="sendSignedTutorialAdvInfo">Advanced Details: <br>locktime is set to 0, sequence is set to max. SIGHASH_ALL option is chosen
                      for signing raw Transaction.</p>
                </div>
              </div>
            </div>
            <div id="Settings" class="tabcontent">
              <label for="explorer" data-i18n="settingsExplorer">Choose an explorer:</label>
              <br>
              <select id="explorer" class="form-control" name="explorer">
                <!-- Populated via JS at DOM load (settings.js) -->
              </select>
              <br>              
              <label for="translation" data-i18n="settingsLanguage">Choose an Language:</label>
              <br>
              <select id="translation" class="form-control" name="translation">
                <!-- Populated via JS at DOM load (settings.js) -->
              </select>
              <br>
	      
              <label for="node" data-i18n="settingsAdonisNode">Choose a ADONIS node:</label>
              <br>
              <select id="node" class="form-control" name="node">
                <!-- Populated via JS at DOM load (settings.js) -->
              </select>
              <br>

              <label for="analytics" data-i18n="settingsAnalytics">Choose your analytics contribution level:</label>
              <br>
              <select id="analytics" class="form-control" name="analytics">
                <!-- Populated via JS at DOM load (settings.js) -->
              </select>
              <div id='analyticsDescriptor'></div>
              <br>

              <button class="adonis-button-big" onclick="toggleDebug()">
                              <span class="buttoni-icon"><i class="fas fa-bug fa-tiny-margin"></i></span>
                              <span class="buttoni-text" data-i18n="settingsToggleDebug">Toggle Debug Mode</span>
                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
              </button>
              <button class="adonis-button-big" onclick="toggleTestnet()">
                              <span class="buttoni-icon"><i class="fas fa-network-wired fa-tiny-margin"></i></span>
                              <span class="buttoni-text" data-i18n="settingsToggleTestnet">Toggle Testnet Mode</span>
                              <span class="buttoni-arrow"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M23.328 16.707L13.121 26.914a.5.5 0 01-.707 0l-2.828-2.828a.5.5 0 010-.707L16.964 16 9.586 8.621a.5.5 0 010-.707l2.828-2.828a.5.5 0 01.707 0l10.207 10.207a1 1 0 010 1.414z"></path></svg></span>
              </button>

            </div>
          </div>
        </div>
      </div>
    </div>
    <!--
      Alert
    -->
    <div class="alertPositioning"></div>
    <footer id="foot">
        <div class="footer">
          <div><span> © MIT 2022 </span> - <span data-i18n="footerBuiltWithAdonisLabs">Built with 💜 by Adonis Network</span><br><a href="https://github.com/adonisexchange/Adon-Web-Wallet" data-i18n="footerGithubLink">Adonis Web Wallet</a></div>
        </div>
    </footer>
  </div>

  <!-- Load frontend-level components -->
  <script type="text/javascript" src="scripts/settings.js"></script>
  <script type="text/javascript" src="scripts/misc.js"></script>
  <script type="text/javascript" src="scripts/wallet.js"></script>
  <script type="text/javascript" src="scripts/network.js"></script>
  <script type="text/javascript" src="scripts/i18n.js"></script>
  <script type="text/javascript" src="scripts/mempool.js"></script>
  <script>
    // TRANSLATION
    //Create an object of objects filled with all the translations
    var translatableLanguages = {
      "en": en_translation,
      "uwu": uwu_translation
    }
    localTranslation = localStorage.getItem('translation')
    // Check if set in local storage
    if(localTranslation != null){
      translation = translatableLanguages[localTranslation]
    }else{
      // Check if we support the user's browser locale
      if (arrActiveLangs.includes(strLang)) {
        translation = translatableLanguages[strLang]
      }else{
        // Default to EN if the locale isn't supported yet
        console.log("i18n: Your language (" + strLang + ") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!")
        translation = en_translation
      }
    }
    translate(translation);

    // WALLET STATE DATA
    const mempool = new Mempool();
    let arrRewards = [];
    let cachedBlockCount = 0;
    //                        Adonis Network' Cold Pool
    let cachedColdStakeAddr = "SZMvAfP3a9GWxHJ9JkFxhRXLnRHyZJ9eHz";

    // Cached DOM elements
    const domStart = document.getElementById("start");
    const domNavbarToggler = document.getElementById("navbarToggler");
    const domGuiStaking = document.getElementById('guiStaking');
    const domGuiWallet = document.getElementById('guiWallet');
    const domGuiBalance = document.getElementById("guiBalance");
    const domGuiBalanceTicker = document.getElementById("guiBalanceTicker");
    const domGuiBalanceBox = document.getElementById("guiBalanceBox");
    const domBalanceReload = document.getElementById("balanceReload");
    const domBalanceReloadStaking = document.getElementById("balanceReloadStaking");
    const domGuiBalanceStaking = document.getElementById("guiBalanceStaking");
    const domGuiBalanceStakingTicker = document.getElementById("guiBalanceStakingTicker");
    const domGuiStakingLoadMore = document.getElementById("stakingLoadMore");
    const domGuiStakingLoadMoreIcon = document.getElementById("stakingLoadMoreIcon");
    const domGuiBalanceBoxStaking = document.getElementById("guiBalanceBoxStaking");
    const domGuiDelegateAmount = document.getElementById('delegateAmount');
    const domGuiUndelegateAmount = document.getElementById('undelegateAmount');
    const domTxTab = document.getElementById("txTab");
    const domStakeTab = document.getElementById("stakeTab");
    const domsendNotice = document.getElementById("sendNotice");
    const domSimpleTXs = document.getElementById("simpleTransactions");
    const domSimpleTXsDropdown = document.getElementById("simpleTransactionsDropdown");
    const domAddress1s = document.getElementById("address1s");
    const domValue1s = document.getElementById("value1s");
    const domGuiViewKey = document.getElementById('guiViewKey');
    const domModalQR = document.getElementById('ModalQR');
    const domModalQrLabel = document.getElementById('ModalQRLabel');
    const domPrefix = document.getElementById('prefix');
    const domPrefixNetwork = document.getElementById('prefixNetwork');
    const domWalletToggle = document.getElementById("wToggle");
    const domGenerateWallet = document.getElementById('generateWallet');
    const domGenVanityWallet = document.getElementById('generateVanityWallet');
    const domGenHardwareWallet = document.getElementById('generateHardwareWallet');
    //GOVERNANCE ELEMENTS
    const domGovProposalsTable = document.getElementById('proposalsTable');
    const domGovProposalsTableBody = document.getElementById('proposalsTableBody');
    //MASTERNODE ELEMENTS
    const domCreateMasternode = document.getElementById('createMasternode');
    const domControlMasternode = document.getElementById('controlMasternode')
    const domAccessMasternode = document.getElementById('accessMasternode');
    const domMnAccessMasternodeText = document.getElementById('accessMasternodeText');
    const domMnCreateType = document.getElementById('mnCreateType');
    const domMnTextErrors = document.getElementById('mnTextErrors');
    const domMnIP = document.getElementById('mnIP');
    const domMnTxId = document.getElementById('mnTxId');
    const domMnPrivateKey = document.getElementById('mnPrivateKey');
    const domMnDashboard = document.getElementById('mnDashboard');
    const domMnProtocol = document.getElementById('mnProtocol');
    const domMnStatus = document.getElementById('mnStatus');
    const domMnNetType = document.getElementById('mnNetType');
    const domMnNetIP = document.getElementById('mnNetIP');
    const domMnLastSeen = document.getElementById('mnLastSeen');

    const domAccessWallet = document.getElementById('accessWallet');
    const domImportWallet = document.getElementById('importWallet');
    const domImportWalletText = document.getElementById('importWalletText');
    const domAccessWalletBtn = document.getElementById('accessWalletBtn');
    const domVanityUiButtonTxt = document.getElementById("vanButtonText");
    const domGenKeyWarning = document.getElementById('genKeyWarning');
    const domEncryptWarningTxt = document.getElementById('encryptWarningText');
    const domEncryptBtnTxt = document.getElementById('encryptButton');
    const domEncryptPasswordBox = document.getElementById('encryptPassword');
    const domEncryptPasswordFirst = document.getElementById('newPassword');
    const domEncryptPasswordSecond = document.getElementById('newPasswordRetype');
    const domGuiAddress = document.getElementById('guiAddress');
    const domGenIt = document.getElementById("genIt");
    const domHumanReadable = document.getElementById("HumanReadable");
    const domTxOutput = document.getElementById("transactionFinal");
    const domReqDesc = document.getElementById('reqDesc');
    const domReqDisplay = document.getElementById('reqDescDisplay');
    const domIdenticon = document.getElementById("identicon");
    const domPrivKey = document.getElementById("privateKey");
    const domPrivKeyPassword = document.getElementById("privateKeyPassword");
    const domAvailToDelegate = document.getElementById('availToDelegate');
    const domAvailToUndelegate = document.getElementById('availToUndelegate');
    const domAnalyticsDescriptor = document.getElementById('analyticsDescriptor');
    const domStakingRewardsList = document.getElementById('staking-rewards-content');
    const domStakingRewardsTitle = document.getElementById('staking-rewards-title');
    const domMnemonicModalContent = document.getElementById("ModalMnemonicContent");
    const domMnemonicModalButton = document.getElementById("modalMnemonicConfirmButton");
    const domExportDiv = document.getElementById("exportKeyDiv");
    const domExportKey = document.getElementById("exportKeyText");
    const domExportWallet = document.getElementById("guiExportWallet");
    const domNewAddress = document.getElementById("guiNewAddress");
    const domConfirmModalHeader = document.getElementById("confirmModalHeader");
    const domConfirmModalTitle = document.getElementById("confirmModalTitle");
    const domConfirmModalContent = document.getElementById("confirmModalContent");
    const domConfirmModalButtons = document.getElementById("confirmModalButtons");
    const domConfirmModalConfirmButton = document.getElementById("confirmModalConfirmButton");
    const domConfirmModalCancelButton = document.getElementById("confirmModalCancelButton");
	  
    const masternodeLegacyAccessText='Access the masternode linked to this address<br> Note: the masternode MUST have been already created (however it can be online or offline)<br>  If you want to create a new masternode access with a HD wallet'
    const masternodeHDAccessText="Access your masternodes if you have any! If you don't you can create one"
    // Aggregate menu screens and links for faster switching
    const arrDomScreens = document.getElementsByClassName("tabcontent");
    const arrDomScreenLinks = document.getElementsByClassName("tablinks");

    // Alert DOM element
    const domAlertPos = document.getElementsByClassName("alertPositioning")[0];

    function getBalance(updateGUI = false) {
      const nBalance = mempool.getBalance();
      
      // Update the GUI too, if chosen
      if (updateGUI) {
        // Set the balance, and adjust font-size for large balance strings
        const nLen = (nBalance / COIN).toFixed(2).length;
        domGuiBalance.innerText = (nBalance / COIN).toFixed(nLen >= 6 ? 0 : 2);
        domAvailToDelegate.innerText = "Available: ~" + (nBalance / COIN).toFixed(2) + " " + cChainParams.current.TICKER;
        
        // Add a notice to the Send page if balance is lacking
        domsendNotice.innerHTML = nBalance ? '' : '<div class="alert alert-danger" role="alert"><h4>Note:</h4><h5>You don\'t have any funds, get some coins first!</h5></div>';
      }

      return nBalance;
    }

    function getStakingBalance(updateGUI = false) {
      const nBalance = mempool.getDelegatedBalance();
      
      if (updateGUI) {
        // Set the balance, and adjust font-size for large balance strings
        domGuiBalanceStaking.innerText = Math.floor(nBalance / COIN);
        domGuiBalanceBoxStaking.style.fontSize = Math.floor(nBalance / COIN).toString().length >= 4 ? "large" : "x-large";
        domAvailToUndelegate.innerText = "Staking: ~" + (nBalance / COIN).toFixed(2) + " " + cChainParams.current.TICKER;
      }

      return nBalance;
    }

    function selectMaxBalance(domValueInput, fCold = false) {
      domValueInput.value = (fCold ? getStakingBalance() : getBalance()) / COIN;
    }

    function updateStakingRewardsGUI(fCallback = false) {
      if (!arrRewards.length) {
        // This ensures we don't spam network requests, since if a network callback says we have no stakes; no point checking again!
        if (!fCallback) getStakingRewards();
        return;
      }
      // DOM-optimised list generation
      const strList = arrRewards.map(cReward => `<i style="opacity: 0.75; cursor: pointer" onclick="window.open('${cExplorer.url + '/tx/' + cReward.id}', '_blank')">${new Date(cReward.time * 1000).toLocaleDateString()}</i> <b>+${cReward.amount} ${cChainParams.current.TICKER}</b>`).join("<br>");
      // Calculate total
      const nRewards = arrRewards.reduce((total, reward) => total + reward.amount, 0);
      // Update DOM
      domStakingRewardsTitle.innerHTML = `Staking Rewards: ≥${nRewards} ${cChainParams.current.TICKER}`;
      domStakingRewardsList.innerHTML = strList;
    }

    // URL-Query request processing
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    let requestTo;
    let requestAmount;
    // Check for a payment request
    if (urlParams.has('pay') && urlParams.has('amount')) {
      requestTo     = urlParams.get('pay');
      requestAmount = parseFloat(urlParams.get('amount'));
      console.log(requestTo + " " + requestAmount);
      // We have our payment request info, wait until the page is fully loaded then display the payment request via .onload
    }

    let audio = null;
    function playMusic() {
      // On first play: load the audio into memory from the host
      if (audio === null) audio = new Audio('assets/music.mp3');

      // Play or Pause
      if (audio.paused || audio.ended) {
        audio.play();
        for (const domImg of document.getElementsByTagName('img')) domImg.classList.add("discoFilter");
      } else {
        audio.pause();
        for (const domImg of document.getElementsByTagName('img')) domImg.classList.remove("discoFilter");
      }
    }

    function toClipboard(source, caller) {
      // Fetch the text/value source
      const domCopy = document.getElementById(source);

      // Use an invisible textbox as the clipboard source
      const domClipboard = document.getElementById('clipboard');
      domClipboard.value = domCopy.value || domCopy.innerHTML;
      domClipboard.select();
      domClipboard.setSelectionRange(0, 99999);

      // Browser-dependent clipboard execution
      if (!navigator.clipboard) {
        document.execCommand("copy");
      } else {
        navigator.clipboard.writeText(domCopy.innerHTML);
      }

      // Display a temporary checkmark response
      caller.classList.add("fa-check");
      caller.classList.remove("fa-clipboard");
      caller.style.cursor = "default";
      setTimeout(() => {
        caller.classList.add("fa-clipboard");
        caller.classList.remove("fa-check");
        caller.style.cursor = "pointer";
      }, 1000);
    }

    function guiPreparePayment(strTo = "", strAmount = 0, strDesc = "") {
      domTxTab.click();
      if (domSimpleTXs.style.display === 'none')
        domSimpleTXsDropdown.click();
      // Apply values
      domAddress1s.value = strTo;
      domValue1s.value = strAmount;
      domReqDesc.value = strDesc;
	    domReqDisplay.style.display = strDesc ? 'block' : 'none';
      domValue1s.focus();
    }

    function hideAllWalletOptions() {
      // Hide and Reset the Vanity address input
      domPrefix.value = "";
      domPrefix.style.display = 'none';

      // Hide all "*Wallet" buttons
      domGenerateWallet.style.display = 'none';
      domImportWallet.style.display = 'none';
      domGenVanityWallet.style.display = 'none';
      domAccessWallet.style.display = 'none';
      domGenHardwareWallet.style.display = 'none';
    }

    async function govVote(hash, voteCode){
      if (await confirmPopup({
          title: ALERTS.CONFIRM_POPUP_VOTE,
          html: ALERTS.CONFIRM_POPUP_VOTE_HTML,
        }) == true) {
        if(localStorage.getItem("masternode")){
          const cMasternode = new Masternode(JSON.parse(localStorage.getItem("masternode")));
          if (await cMasternode.getStatus() !== "ENABLED") {
            createAlert("warning","Your masternode is not enabled yet!", 6000);
            return;
          }
          const result = await cMasternode.vote(hash.toString(), voteCode); //1 yes 2 no
          if (result.includes("Voted successfully")) { //good vote
            createAlert('success', 'Vote submitted!', 6000);
          } else if(result.includes("Error voting :")) { //If you already voted return an alert
            createAlert('warning', 'You already voted for this proposal! Please wait 1 hour', 6000);
          } else if(result.includes("Failure to verify signature.")) { //wrong masternode private key
            createAlert('warning', 'Failed to verify signature, please check your masternode\'s private key', 6000);
          } else { //this could be everything
	          console.error(result);
            createAlert('warning', 'Internal error, please try again later', 6000);
          }
        } else {
          createAlert('warning', 'Access a masternode before voting!', 6000);
        }
      }
    }

    async function startMasternode(fRestart = false) {
      if (localStorage.getItem("masternode")) {
        const cMasternode = new Masternode(JSON.parse(localStorage.getItem("masternode")));
        if (await cMasternode.start()) {
          createAlert('success', '<b>Masternode ' + (fRestart ? 're' : '') + 'started!</b>', 4000);
        } else {
          createAlert('warning', '<b>Failed to ' + (fRestart ? 're' : '') + 'start masternode!</b>', 4000);
        }
      }
    }

    function destroyMasternode() {
      if (localStorage.getItem("masternode")) {
        localStorage.removeItem("masternode");
        createAlert('success', '<b>Masternode destroyed!</b><br>Your coins are now spendable.', 5000);
        updateMasternodeTab();
      }
    }

    async function createMasternode() {
      const fGeneratePrivkey = domMnCreateType.value === "VPS";
      const [strAddress,strAddressPath] = await getNewAddress();
      const nValue = cChainParams.current.collateralInSats;
    
      const nBalance = getBalance();
      const cTx = bitjs.transaction();
      const cCoinControl = chooseUTXOs(cTx, nValue, 0, false);
      
      if (!cCoinControl.success) return alert(cCoinControl.msg);
      // Compute fee
      const nFee = getFee(cTx.serialize().length);
      
      // Compute change (or lack thereof)
      const nChange = cCoinControl.nValue - (nFee + nValue);
      const [changeAddress,changeAddressPath] = await getNewAddress({verify: masterKey.isHardwareWallet});
      const outputs = [];
      if (nChange > 0) {
        // Change output
        outputs.push([changeAddress, nChange / COIN]);
      } else {
       return createAlert("warning", "You don't have enough " + cChainParams.current.TICKER + " to create a masternode", 5000);
      }
      
      // Primary output (receiver)
      outputs.push([strAddress, nValue / COIN]);
      
      // Debug-only verbose response
      if (debug) domHumanReadable.innerHTML = "Balance: " + (nBalance / COIN) + "<br>Fee: " + (nFee / COIN) + "<br>To: " + strAddress + "<br>Sent: " + (nValue / COIN) + (nChange > 0 ? "<br>Change Address: " + changeAddress + "<br>Change: " + (nChange / COIN) : "");

      // Add outputs to the Tx
      for (const output of outputs) {
        cTx.addoutput(output[0], output[1]);
      }

      // Sign and broadcast!
      if (!masterKey.isHardwareWallet) {
        const sign = await cTx.sign(masterKey, 1);
        const result = await sendTransaction(sign);
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(sign)))))));
          mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,vout: 0,script:Crypto.util.bytesToHex(cTx.outputs[0].script),status: Mempool.PENDING})
          mempool.addUTXO({id: futureTxid,path: strAddressPath,script:Crypto.util.bytesToHex(cTx.outputs[1].script),sats: nValue,vout: 1,status: Mempool.PENDING})
        }
      } else {
        // Format the inputs how the Ledger SDK prefers
        const arrInputs = [];
        const arrAssociatedKeysets = [];
        for (const cInput of cTx.inputs) {
          const cInputFull = await getTxInfo(cInput.outpoint.hash);
          arrInputs.push([await cHardwareWallet.splitTransaction(cInputFull.hex), cInput.outpoint.index]);
          arrAssociatedKeysets.push(cInput.path);
        }
        const cLedgerTx = await cHardwareWallet.splitTransaction(cTx.serialize());
              const strOutputScriptHex = await cHardwareWallet
          .serializeTransactionOutputs(cLedgerTx)
          .toString("hex");

        // Sign the transaction via Ledger
        const strSerialisedTx = await confirmPopup(
          {
            title: ALERTS.CONFIRM_POPUP_TRANSACTION,
            html: createTxConfirmation(outputs),
            resolvePromise: cHardwareWallet.createPaymentTransactionNew({
              inputs: arrInputs,
              associatedKeysets: arrAssociatedKeysets,
              outputScriptHex: strOutputScriptHex,
            }),
          }
        );

        // Broadcast the Hardware (Ledger) TX
        const result = await sendTransaction(strSerialisedTx);
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(strSerialisedTx)))))));
          mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,vout: 0,script:Crypto.util.bytesToHex(cTx.outputs[0].script),status: Mempool.PENDING});
          mempool.addUTXO({id: futureTxid,path: strAddressPath,script:Crypto.util.bytesToHex(cTx.outputs[1].script),sats: nValue,vout: 1,status: Mempool.PENDING});
        }
        
      }
      if(fGeneratePrivkey){
        let masternodePrivateKey= await generateMnPrivkey();
        await confirmPopup({
          title: ALERTS.CONFIRM_POPUP_MN_P_KEY,
          html: masternodePrivateKey + ALERTS.CONFIRM_POPUP_MN_P_KEY_HTML, 
        });
      }
      createAlert("success", "<b>Masternode Created!<b><br>Wait 15 confirmations to proceed further");
      // Remove any previous Masternode data, if there were any
      localStorage.removeItem("masternode");
    }
    async function importMasternode(){
      const mnPrivKey = domMnPrivateKey.value;
      
      const ip = domMnIP.value;
      let address;
      let collateralTxId;
      let outidx;
      let collateralPrivKeyPath;
      domMnIP.value = "";
      domMnPrivateKey.value = "";

      if (!ip.includes(":")) {
	address = `${ip}:${cChainParams.current.MASTERNODE_PORT}`;
      } else {
	address = ip;
      }
      
      if (!masterKey.isHD) {
        // Find the first UTXO matching the expected collateral size
        const cCollaUTXO = mempool.getConfirmed().find(cUTXO => cUTXO.sats === cChainParams.current.collateralInSats);

        // If there's no valid UTXO, exit with a contextual message
        if (!cCollaUTXO) {
          if (getBalance(false) < cChainParams.current.collateralInSats) {
            // Not enough balance to create an MN UTXO
            createAlert("warning", "You need <b>" + ((cChainParams.current.collateralInSats - getBalance(false)) / COIN) + " more " + cChainParams.current.TICKER + "</b> to create a Masternode!", 10000);
          } else {
            // Balance is capable of a masternode, just needs to be created
            // TODO: this UX flow is weird, is it even possible? perhaps we can re-design this entire function accordingly
            createAlert("warning", "You have enough balance for a Masternode, but no valid collateral UTXO of " + (cChainParams.current.collateralInSats / COIN) + " " + cChainParams.current.TICKER, 10000);
          }
          return;
        }

        collateralTxId = cCollaUTXO.id;
        outidx = cCollaUTXO.vout;
        collateralPrivKeyPath = "legacy";
      } else {
        const path = domMnTxId.value;
        const masterUtxo = mempool.getConfirmed().findLast(u=>u.path === path); // first UTXO for each address in HD
        // sanity check:
        if (masterUtxo.sats !== cChainParams.current.collateralInSats) {
          return createAlert("warning", "This is not a suitable UTXO for a Masternode", 10000);
        }
        collateralTxId = masterUtxo.id;
        outidx = masterUtxo.vout;
        collateralPrivKeyPath = path;     
      }
      domMnTxId.value = "";

      
      const cMasternode = new Masternode({
        walletPrivateKeyPath: collateralPrivKeyPath,
        mnPrivateKey: mnPrivKey,
        collateralTxId: collateralTxId,
        outidx: outidx,
        addr: address
      });
      await refreshMasternodeData(cMasternode, true);
      await updateMasternodeTab();
    }

    function accessOrImportWallet() {
      // Hide and Reset the Vanity address input
      domPrefix.value = "";
      domPrefix.style.display = 'none';

      // Show Import button, hide access button
      domImportWallet.style.display = 'block';
      domAccessWalletBtn.style.display = 'none';

      // If we have a local wallet, display the decryption prompt
      if (hasEncryptedWallet()) {
        domPrivKey.placeholder = 'Enter your wallet password';
        domImportWalletText.innerText = 'Unlock Wallet';
        domPrivKey.focus();
      }
    }

    function onPrivateKeyChanged() {
      if (hasEncryptedWallet()) return;
      // Check whether the length of the string is 128 bytes (that's the length of ciphered plain texts)
      // and it doesn't have any spaces (would be a mnemonic seed)
      const fContainsSpaces = domPrivKey.value.includes(" ");
      domPrivKeyPassword.hidden = domPrivKey.value.length !== 128 || fContainsSpaces;

      // Uncloak the private input IF spaces are detected, to make Seed Phrases easier to input and verify
      domPrivKey.setAttribute('type', fContainsSpaces ? 'text' : 'password');
    }

    async function guiImportWallet() {
      const fEncrypted = domPrivKey.value.length === 128;

      // If we are in testnet: prompt an import
      if (cChainParams.current.isTestnet) return importWallet();

      // If we don't have a DB wallet and the input is plain: prompt an import
      if (!hasEncryptedWallet() && !fEncrypted) return importWallet();

      // If we don't have a DB wallet and the input is ciphered: 
      const strPrivKey = domPrivKey.value
      const strPassword = domPrivKeyPassword.value;
      if (!hasEncryptedWallet() && fEncrypted) {
        const strDecWIF = await decrypt(strPrivKey, strPassword);
        if (!strDecWIF || strDecWIF === "decryption failed!") {
          return createAlert('warning', ALERTS.FAILED_TO_IMPORT, [], 6000);
        } else {
          localStorage.setItem("encwif", strPrivKey);
          return importWallet({
            newWif: strDecWIF
          });
        }
      }
      // Prompt for decryption of the existing wallet
      const fHasWallet = await decryptWallet(domPrivKey.value);

      // If the wallet was successfully loaded, hide all options and load the dash!
      if (fHasWallet) hideAllWalletOptions();
    }

    function guiEncryptWallet() {
      // Disable wallet encryption in testnet mode
      if (cChainParams.current.isTestnet) return createAlert('warning', ALERTS.TESTNET_ENCRYPTION_DISABLED, [], 2500);

      // Show our inputs if we haven't already
      if (domEncryptPasswordBox.style.display === 'none') {
        // Return the display to it's class form
        domEncryptPasswordBox.style.display = '';
        domEncryptBtnTxt.innerText = 'Finish Encryption';
      } else {
        // Fetch our inputs, ensure they're of decent entropy + match eachother
        const strPass = domEncryptPasswordFirst.value,
              strPassRetype = domEncryptPasswordSecond.value;
        if (strPass.length < MIN_PASS_LENGTH) return createAlert('warning', ALERTS.PASSWORD_TOO_SMALL, [{"MIN_PASS_LENGTH" : MIN_PASS_LENGTH}], 4000);
        if (strPass !== strPassRetype) return createAlert('warning', ALERTS.PASSWORD_DOESNT_MATCH, [], 2250);
        encryptWallet(strPass);
        createAlert('success', ALERTS.NEW_PASSWORD_SUCCESS, [], 5500);
      }
    }

    function createAddressConfirmation(address) {
      return `Please confirm this is the address you see on your ${strHardwareName}.
              <div class="seed-phrase">${address}</div>`;
    }

    function createTxConfirmation(outputs) {
      let strHtml = "Confirm this transaction matches the one on your " + strHardwareName +  ".";
      for (const output of outputs) {
        strHtml += `<br> <br> You will send <b>${output[1].toFixed(2)} ${cChainParams.current.TICKER}</b> to <div class="inline-address">${output[0]}</div>`
      }
      return strHtml;
    }

    async function toggleExportUI() {
      domExportDiv.hidden = !domExportDiv.hidden;
      if (!domExportDiv.hidden) {
        domExportKey.innerText = hasEncryptedWallet() ? localStorage.getItem("encwif") : masterKey.keyToBackup;
      } else {
        domExportKey.innerText = "";
      }
    }
    
    let addressIndex = 0;
    async function isYourAddress(address){
      let i=0;
      while(i<addressIndex){
        const path = getDerivationPath(masterKey.isHardwareWallet, 0, 0, i);
        const testAddress = await masterKey.getAddress(path);
        if(address===testAddress){
          return [true,path];
        }
        i++;
      }
      return [false,0];
    }
    async function getNewAddress({updateGUI = false, verify = false} = {}) {
      const last = lastWallet || 0;
      addressIndex = addressIndex > last ? addressIndex : last + 1;
      if (addressIndex - last > MAX_ACCOUNT_GAP) {
        // If the user creates more than ${MAX_ACCOUNT_GAP} empty wallets we will not be able to sync them!
        addressIndex = last;
      }
      const path = getDerivationPath(masterKey.isHardwareWallet, 0, 0, addressIndex);
      // Use Xpub?
      const address = await masterKey.getAddress(path);
      if (verify && masterKey.isHardwareWallet) {
        // Generate address to present to the user without asking to verify
        const confAddress = await confirmPopup({
          title: ALERTS.CONFIRM_POPUP_VERIFY_ADDR,
          html: createAddressConfirmation(address),
          resolvePromise: masterKey.getAddress(path, { verify })
        });
        if (address !== confAddress) {
          throw new Error("User did not verify address");
        }
      }

      if (updateGUI) {
        domGuiAddress.innerText = address;
        createQR('adonis:' + address, domModalQR);
        domModalQrLabel.innerHTML = 'adonis:' + address;
        domModalQR.firstChild.style.width = "100%";
        domModalQR.firstChild.style.height = "auto";
        domModalQR.firstChild.style.imageRendering = "crisp-edges";
        document.getElementById('clipboard').value = address;
      }
      addressIndex++;
      return [address,path];
    }

    function checkVanity() {
        var e = event || window.event;  // get event object
        var key = e.keyCode || e.which; // get key cross-browser
        var char = String.fromCharCode(key).trim(); // convert key to char
        if(char.length == 0) return;

        // Ensure the input is base58 compatible
        if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) {
          if (e.preventDefault) e.preventDefault();
          e.returnValue = false;
          return createAlert('warning',ALERTS.UNSUPPORTED_CHARACTER, [{"char" : char}], 3500);
        }
    }

    let isVanityGenerating = false;
    const arrWorkers = [];
    let vanUiUpdater;

    function stopSearch() {
      isVanityGenerating = false;
      for (let thread of arrWorkers) {
        thread.terminate();
      }
      while (arrWorkers.length) arrWorkers.pop();
      domPrefix.disabled = false;
      domVanityUiButtonTxt.innerText = 'Create A Vanity Wallet';
      clearInterval(vanUiUpdater);
    }

    async function generateVanityWallet() {
      if (isVanityGenerating) return stopSearch();
      if (typeof(Worker) === "undefined") return createAlert('error', ALERTS.UNSUPPORTED_WEBWORKERS, [], 7500);
      // Generate a vanity address with the given prefix
      if (domPrefix.value.length === 0 || domPrefix.style.display === 'none') {
        // No prefix, display the intro!
        domPrefix.style.display = 'block';
        domGenKeyWarning.style.display = 'none';
        domGuiAddress.innerHTML = "~";
        domPrefix.focus();
      } else {
        // Remove spaces from prefix
        domPrefix.value = domPrefix.value.replace(/ /g, "");

        // Cache a lowercase equivilent for lower-entropy comparisons (a case-insensitive search is ALOT faster!) and strip accidental spaces
        const nInsensitivePrefix = domPrefix.value.toLowerCase();
        const nPrefixLen = nInsensitivePrefix.length;

        // Ensure the input is base58 compatible
        for (const char of domPrefix.value) {
          if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) return createAlert('warning',ALERTS.UNSUPPORTED_CHARACTER, [{"char" : char}], 3500);
        }
        // We also don't want users to be mining addresses for years... so cap the letters to four until the generator is more optimized
        if (domPrefix.value.length > 5) return createAlert('warning', ALERTS.UNSUPPORTED_CHARACTER, [{"char" : char}], 3500);
        isVanityGenerating = true;
        domPrefix.disabled = true;
        let attempts = 0;

        // Setup workers
        const nThreads = Math.max(Math.floor(window.navigator.hardwareConcurrency * 0.75), 1);
        console.log('Spawning ' + nThreads + ' vanity search threads!');
        while (arrWorkers.length < nThreads) {
          arrWorkers.push(new Worker("scripts/vanitygen_worker.js"));
          arrWorkers[arrWorkers.length - 1].onmessage = (event) => checkResult(event.data);
          arrWorkers[arrWorkers.length - 1].postMessage(cChainParams.current.PUBKEY_ADDRESS);
        }

        // GUI Updater
        domVanityUiButtonTxt.innerText = 'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';
        vanUiUpdater = setInterval(() => {
            domVanityUiButtonTxt.innerText = 'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';
        }, 200);

        function checkResult(data) {
          attempts++;
          if (data.pub.substr(1, nPrefixLen).toLowerCase() == nInsensitivePrefix) {
            importWallet({
              newWif: data.priv,
              fRaw: true
            });
            stopSearch();
            domGuiBalance.innerHTML = "0";
            domGuiBalanceBox.style.fontSize = "x-large";
            return console.log("VANITY: Found an address after " + attempts + " attempts!");
          }
        }
      }
    }

    function toggleDropDown(id) {
      const domID = document.getElementById(id);
      domID.style.display = domID.style.display === 'block' ? 'none' : 'block';
    }

    function createAlertWithFalse() {
      createAlert(...arguments);
      return false;
    }

    function validateAmount(nAmountSats, nMinSats = 10000) {
      // Validate the amount is a valid number, and meets the minimum (if any)
      if (nAmountSats < nMinSats || isNaN(nAmountSats))
        return createAlertWithFalse('warning', ALERTS.INVALID_AMOUNT + ALERTS.VALIDATE_AMOUNT_LOW, [{"minimumAmount" : (nMinSats / COIN)}, {"coinTicker" : cChainParams.current.TICKER}], 2500);

      // Validate the amount in Satoshi terms meets the coin's native decimal depth
      if (!Number.isSafeInteger(nAmountSats))
        return createAlertWithFalse('warning', ALERTS.INVALID_AMOUNT + '<br>' + ALERTS.VALIDATE_AMOUNT_DECIMAL,[{"coinDecimal" : COIN_DECIMALS}], 2500);

      // Amount looks valid!
      return true;
    }

    function undelegateGUI() {
      // Verify the amount
      const nAmount = Math.round(Number(domGuiUndelegateAmount.value.trim()) * COIN);
      if(!validateAmount(nAmount)) return;
      undelegate(nAmount);
    }

    async function undelegate(nValue) {
      if (!hasWalletUnlocked(true)) return;
      
      // Construct a TX and fetch Cold inputs
      const nBalance = getStakingBalance();
      const cTx = bitjs.transaction();
      const cCoinControl = chooseUTXOs(cTx, nValue, 0, true);
      if (!cCoinControl.success) return alert(cCoinControl.msg);

      // Compute fee and change (or lack thereof)
      const nFee = getFee(cTx.serialize().length);
      const nChange = cCoinControl.nValue - (nFee + nValue);
      const fReDelegateChange = nChange > 1.01 * COIN;
      let reDelegateAddress;
      let reDelegateAddressPath;
      if (fReDelegateChange) {
        // Enough change to resume cold staking, so we'll re-delegate change to the cold staking address
         // Ensure the user has an address set - if not, request one!, Sanity
        if (!cachedColdStakeAddr || cachedColdStakeAddr.length !== 34 || !cachedColdStakeAddr.startsWith(cChainParams.current.STAKING_PREFIX)) {
          askForCSAddr(true);
          return createAlert('success', ALERTS.SUCCESS_STAKING_ADDR ,[]);
        }
        // The re-delegated change output
        [reDelegateAddress,reDelegateAddressPath] = await getNewAddress();
        cTx.addcoldstakingoutput(reDelegateAddress, cachedColdStakeAddr, nChange / COIN);
        console.log('Re-delegated delegation spend change!');
      } else {
        // Not enough change to cold stake, so we'll just unstake everything (and deduct the fee from the value)
        nValue -= nFee;
        console.log('Spent all CS dust into redeem address!');
      }

      const [outputKey,outputKeyPath] = await getNewAddress();
      // The primary Cold-to-Public output
      cTx.addoutput(outputKey, nValue / COIN);

      // Debug-only verbose response
      if (debug) domHumanReadable.innerHTML = "Balance: " + (nBalance / COIN) + "<br>Fee: " + (nFee / COIN) + "<br>To: " + outputKey + "<br>Sent: " + (nValue / COIN) + (nChange > 0 ? "<br>Change Address: " + (fReDelegateChange ? cachedColdStakeAddr : outputKey) + "<br>Change: " + (nChange / COIN) : "");

      if (hasHardwareWallet()) {
        // Format the inputs how the Ledger SDK prefers
        const arrInputs = [];
        const arrAssociatedKeysets = [];
        for (const cInput of cTx.inputs) {
          const cInputFull = await getTxInfo(cInput.outpoint.hash);
          arrInputs.push([await cHardwareWallet.splitTransaction(cInputFull.hex), cInput.outpoint.index]);
          arrAssociatedKeysets.push(cInput.path);
        }

        // Construct the Ledger transaction
        const cLedgerTx = await cHardwareWallet.splitTransaction(cTx.serialize());
        const strOutputScriptHex = await cHardwareWallet
          .serializeTransactionOutputs(cLedgerTx)
          .toString("hex");

        // Sign the transaction via Ledger
        createAlert("info", ALERTS.CONFIRM_UNSTAKE_H_WALLET, [{"strHardwareName" : strHardwareName}], 7500);
        const cLedgerSignedTx = await cHardwareWallet.createPaymentTransactionNew({
          inputs: arrInputs,
          associatedKeysets: arrAssociatedKeysets,
          outputScriptHex: strOutputScriptHex,
        });
        const nInputLen = cTx.inputs.length;

        // Put public key bytes instead of [3,195,174...]
        const arrSignedTxBytes = Crypto.util.hexToBytes(cLedgerSignedTx);
        const arrPubkey = findCompressedPubKey(arrSignedTxBytes);
        const arrPubkeyWithScriptLen = addScriptLength(arrSignedTxBytes, arrPubkey, nInputLen);
        const arrPubkeyWithScript = addExtraBytes(arrPubkeyWithScriptLen, arrPubkey, nInputLen);

        const strSerialisedTx = Crypto.util.bytesToHex(arrPubkeyWithScript);

        // Broadcast the Hardware (Ledger) TX
        const result = await sendTransaction(strSerialisedTx, "<b>Delegation successfully spent!</b>");
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          // Add our undelegation + change re-delegation (if any) to the local mempool
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(strSerialisedTx)))))));
          if(fReDelegateChange){
            mempool.addUTXO({id: futureTxid,path: reDelegateAddressPath,script:Crypto.util.bytesToHex(cTx.outputs[0].script) ,sats: nChange,vout: 0,status: Mempool.PENDING_COLD});
            mempool.addUTXO({id: futureTxid,path: outputKeyPath,script:Crypto.util.bytesToHex(cTx.outputs[1].script) ,sats: nValue,vout: 1,status: Mempool.PENDING});
          }else{
            mempool.addUTXO({id: futureTxid,path: outputKeyPath,sats: nValue,script:Crypto.util.bytesToHex(cTx.outputs[0].script),vout: 0,status: Mempool.PENDING});
          }
        }
      } else {
         let sign= await cTx.sign(masterKey, 1, 'coldstake');
        // Broadcast the software TX
  
        const result = await sendTransaction(sign, "<b>Delegation successfully spent!</b>");
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          // Add our undelegation + change re-delegation (if any) to the local mempool
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(sign)))))));
          if(fReDelegateChange){
            mempool.addUTXO({id: futureTxid,path:reDelegateAddressPath,script:Crypto.util.bytesToHex(cTx.outputs[0].script) ,sats: nChange,vout: 0,status: Mempool.PENDING_COLD});
            mempool.addUTXO({id: futureTxid,path: outputKeyPath,script:Crypto.util.bytesToHex(cTx.outputs[1].script) ,sats: nValue,vout: 1,status: Mempool.PENDING});
          }else{
            mempool.addUTXO({id: futureTxid,path: outputKeyPath,sats: nValue,script:Crypto.util.bytesToHex(cTx.outputs[0].script),vout: 0,status: Mempool.PENDING});
          }
        }
      }

      domGenIt.innerHTML = "Continue";
    }

    function askForCSAddr(force = false) {
      if (force) cachedColdStakeAddr = null;
      if (cachedColdStakeAddr === "" || cachedColdStakeAddr === null) {
        cachedColdStakeAddr = prompt('Please provide a Cold Staking address (either from your own node, or a 3rd-party!)').trim();
        if (cachedColdStakeAddr) return true;
      } else {
        return true;
      }
      return false;
    }

    function delegateGUI() {
      // Verify the amount; Delegations must be a minimum of 1 ADON, enforced by the network
      const nAmount = Number(domGuiDelegateAmount.value.trim()) * COIN;
      if (!validateAmount(nAmount, COIN)) return;

      // Ensure the user has an address set - if not, request one!
      if (!askForCSAddr()) return;      

      // Sanity
      if (cachedColdStakeAddr.length !== 34 || !cachedColdStakeAddr.startsWith(cChainParams.current.STAKING_PREFIX)) {
        askForCSAddr(true);
        return createAlert('success', ALERTS.SUCCESS_STAKING_ADDR_SET, []);
      }
      delegate(nAmount, cachedColdStakeAddr);
    }

    async function delegate(nValue, coldAddr) {
      if (!hasWalletUnlocked(true)) return;

      // Construct a TX and fetch Standard inputs
      const nBalance = getBalance();
      const cTx = bitjs.transaction();
      const cCoinControl = chooseUTXOs(cTx, nValue, 0, false);
      if (!cCoinControl.success) return alert(cCoinControl.msg);

      // Compute fee and change (or lack thereof)
      const nFee = getFee(cTx.serialize().length);
      const nChange = cCoinControl.nValue - (nFee + nValue);
      const [changeAddress,changeAddressPath]= await getNewAddress();
      if (nChange > 0) {
        // Change output
        cTx.addoutput(changeAddress, nChange / COIN);
      } else {
        // We're sending alot! So we deduct the fee from the send amount. There's not enough change to pay it with!
        nValue -= nFee;
      }

      // The primary Standard-to-Cold output
      const [primaryAddress, primaryAddressPath]= await getNewAddress();
      cTx.addcoldstakingoutput(primaryAddress, coldAddr, nValue / COIN);

      // Debug-only verbose response
      if (debug) domHumanReadable.innerHTML = "Balance: " + (nBalance / COIN) + "<br>Fee: " + (nFee / COIN) + "<br>To: " + coldAddr + "<br>Sent: " + (nValue / COIN) + (nChange > 0 ? "<br>Change Address: " + changeAddress + "<br>Change: " + (nChange / COIN) : "");

      // Sign and broadcast!
      if (hasHardwareWallet()) {
        // Format the inputs how the Ledger SDK prefers
        const arrInputs = [];
        const arrAssociatedKeysets = [];
        for (const cInput of cTx.inputs) {
          const cInputFull = await getTxInfo(cInput.outpoint.hash);
          arrInputs.push([await cHardwareWallet.splitTransaction(cInputFull.hex), cInput.outpoint.index]);
          arrAssociatedKeysets.push(cInput.path);
        }

        // Construct the Ledger transaction
        const cLedgerTx = await cHardwareWallet.splitTransaction(cTx.serialize());
        const strOutputScriptHex = await cHardwareWallet
          .serializeTransactionOutputs(cLedgerTx)
          .toString("hex");

        // Sign the transaction via Ledger
        createAlert("info", ALERTS.CONFIRM_UNSTAKE_H_WALLET, [{"strHardwareName" : strHardwareName}], 7500);
        const strSerialisedTx = await cHardwareWallet.createPaymentTransactionNew({
          inputs: arrInputs,
          associatedKeysets: arrAssociatedKeysets,
          outputScriptHex: strOutputScriptHex,
        });
        
     
        // Broadcast the Hardware (Ledger) tx
        const result = await sendTransaction(strSerialisedTx, "<b>Delegation successful!</b>");
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(strSerialisedTx)))))));
      
          if(nChange>0){
            mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,script:Crypto.util.bytesToHex(cTx.outputs[0].script),vout: 0,status: Mempool.PENDING});
            mempool.addUTXO({id: futureTxid,path: primaryAddressPath,sats: nValue,vout: 1,script:Crypto.util.bytesToHex(cTx.outputs[1].script),status: Mempool.PENDING_COLD});
          }else{
            mempool.addUTXO({id: futureTxid,path: primaryAddressPath,script: Crypto.util.bytesToHex(cTx.outputs[0].script),sats: nValue,vout: 0,status: Mempool.PENDING_COLD});
          }
        }
      
      } else {
        
        const sign= await cTx.sign(masterKey, 1);
    
        // Broadcast the software TX
        const result = await sendTransaction(sign, "<b>Delegation successful!</b>");
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          // Add our delegation + change (if any) to the local mempool
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(sign)))))));
          if(nChange>0){
            mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,script:Crypto.util.bytesToHex(cTx.outputs[0].script),vout: 0,status: Mempool.PENDING});
            mempool.addUTXO({id: futureTxid,path: primaryAddressPath,sats: nValue,vout: 1,script:Crypto.util.bytesToHex(cTx.outputs[1].script),status: Mempool.PENDING_COLD});
          }else{
            mempool.addUTXO({id: futureTxid,path: primaryAddressPath,script: Crypto.util.bytesToHex(cTx.outputs[0].script),sats: nValue,vout: 0,status: Mempool.PENDING_COLD});
          }
        }
        
      }
      domGenIt.innerHTML = "Continue";
    }

    // Coin Control response formats
    function ccError    (msg = '') { return { success: false, msg } };
    function ccSuccess  (data)     { return { success: true, ...data } };

    function chooseUTXOs(cTx, nTotalSatsRequired = 0, nMinInputSize = 0, fColdOnly = false) {
      console.log("Constructing TX of value: " + (nTotalSatsRequired / COIN) + " " + cChainParams.current.TICKER);

      // Select the UTXO type bucket

      //const arrUTXOs
      const arrUTXOs = mempool.UTXOs;

      // Select and return UTXO pointers (filters applied)
      const cCoinControl = { nValue: 0, nChange: 0, arrSelectedUTXOs: [] }
      
      let spent=[]
      for(let i=0; i< arrUTXOs.length;i++){
        const cUTXO= arrUTXOs[i]
        if(!fColdOnly){
          if(cUTXO.status!==Mempool.CONFIRMED && cUTXO.status!==Mempool.REWARD && cUTXO.status!==Mempool.PENDING){
            continue;
          }
          if(cUTXO.status===Mempool.REWARD && !Mempool.isValidReward(cUTXO)){
            continue
          }
        }
        if(fColdOnly && cUTXO.status!==Mempool.DELEGATE && cUTXO.status!==Mempool.PENDING_COLD) continue;
        // Don't spend locked Masternode collaterals
        if (isMasternodeUTXO(cUTXO)) continue; //CHANGE THIS

        // Have we met the required sats threshold?
        if (cCoinControl.nValue >= nTotalSatsRequired + getFee(cTx.serialize().length)) {
          // Required Coin Control value met, yahoo!
          console.log("Coin Control: TX Constructed! Selected " + cCoinControl.arrSelectedUTXOs.length + " input(s) (" + (cCoinControl.nValue / COIN) + " " + cChainParams.current.TICKER + ")");
          break;
        }

        // Does the UTXO meet size requirements?
        if (cUTXO.sats < nMinInputSize) continue;
        
        // Push UTXO and cache new total value
        cCoinControl.arrSelectedUTXOs.push(cUTXO);
        cCoinControl.nValue += cUTXO.sats;
        console.log("Coin Control: Selected input " + cUTXO.id.substr(0, 6) + "(" + cUTXO.vout + ")... (Added " + (cUTXO.sats / COIN) + " " + cChainParams.current.TICKER + " - Total: " + (cCoinControl.nValue / COIN) + ")");

        // Stuff UTXO into the TX
        cTx.addinput({
          txid: cUTXO.id,
          index: cUTXO.vout,
          script: cUTXO.script,
          path: cUTXO.path
        });
        spent.push(cUTXO);
      }

      // if we don't have enough value: return false
      if (cCoinControl.nValue < nTotalSatsRequired) return ccError("Balance is too small! (Missing " + (cCoinControl.nValue - nTotalSatsRequired).toLocaleString('en-gb') + " sats)");

      // Reaching here: we have sufficient UTXOs, calc final misc data and return!
      cCoinControl.nChange = nTotalSatsRequired - cCoinControl.nValue;
      return ccSuccess(cCoinControl);
    }

  function isMasternodeUTXO(cUTXO, masternode = null) {
      const cMasternode = masternode || JSON.parse(localStorage.getItem("masternode"));
      if (cMasternode) {
	  const { collateralTxId, outidx } = cMasternode;
	  return collateralTxId === cUTXO.id && cUTXO.vout === outidx;
      } else {
	  return false;
      }
    }


    async function createTxGUI() {
      if (!hasWalletUnlocked(true)) return;
      
      // Clear the inputs on 'Continue'
      if (domGenIt.innerHTML === 'Continue') {
	domGenIt.innerHTML = 'Send Transaction';
	domTxOutput.innerHTML = '';
	domHumanReadable.innerHTML = "";
	domValue1s.value = "";
	domAddress1s.value = "";
	domReqDesc.value = '';
	domReqDisplay.style.display = 'none';
	return;
      }
      // Sanity check the address
      const address = domAddress1s.value.trim();
      // If Staking address: redirect to staking page
      if (address.startsWith(cChainParams.current.STAKING_PREFIX)) {
	createAlert('warning', ALERTS.STAKE_NOT_SEND, [], 7500);
	return domStakeTab.click();
      }
      if (address.length !== 34) return createAlert('warning', ALERTS.BAD_ADDR_LENGTH,[{"addressLength" : address.length}], 2500);
      if (!cChainParams.current.PUBKEY_PREFIX.includes(address[0])) return createAlert('warning', ALERTS.BAD_ADDR_PREFIX, [{"address" : address[0]},{"addressPrefix" : cChainParams.current.PUBKEY_PREFIX.join(' or ')}], 3500);
      if (!bitjs.isValidDestination(address,cChainParams.current.PUBKEY_ADDRESS)) return createAlert('warning', ALERTS.INVALID_ADDRESS, [{"address" :address}], 3500);
      
      // Sanity check the amount
      let nValue = Math.round(Number(domValue1s.value.trim()) * COIN);
      if (nValue <= 0 || isNaN(nValue))  return createAlert('warning', ALERTS.INVALID_AMOUNT +ALERTS.SENT_NOTHING, [], 2500);
      if (!Number.isSafeInteger(nValue)) return createAlert('warning', ALERTS.INVALID_AMOUNT +ALERTS.MORE_THEN_8_DECIMALS, [], 2500);
      
      // Construct a TX and fetch Standard inputs
      const nBalance = getBalance();
      const cTx = bitjs.transaction();
      const cCoinControl = chooseUTXOs(cTx, nValue, 0, false);
      if (!cCoinControl.success) return alert(cCoinControl.msg);
      // Compute fee
      const nFee = getFee(cTx.serialize().length);
      
      // Compute change (or lack thereof)
      const nChange = cCoinControl.nValue - (nFee + nValue);
      const [changeAddress,changeAddressPath] = await getNewAddress({verify: masterKey.isHardwareWallet});

      const outputs = [];
      if (nChange > 0) {
        // Change output
        outputs.push([changeAddress, nChange / COIN]);
      } else {
        // We're sending alot! So we deduct the fee from the send amount. There's not enough change to pay it with!
        nValue -= nFee;
      }
      
      // Primary output (receiver)
      outputs.push([address, nValue / COIN]);
      
      // Debug-only verbose response
      if (debug) domHumanReadable.innerHTML = "Balance: " + (nBalance / COIN) + "<br>Fee: " + (nFee / COIN) + "<br>To: " + address + "<br>Sent: " + (nValue / COIN) + (nChange > 0 ? "<br>Change Address: " + changeAddress + "<br>Change: " + (nChange / COIN) : "");

      // Add outputs to the Tx
      for (const output of outputs) {
        cTx.addoutput(output[0], output[1]);
      }
  

      // Sign and broadcast!
      if (!masterKey.isHardwareWallet) {
        const sign = await cTx.sign(masterKey, 1);

        const result = await sendTransaction(sign);
        // Add our change (if any) to the local mempool
        if(result){
          
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
          const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(sign)))))));
            
          const [isYours,yourPath]= await isYourAddress(address);
          if(nChange>0){
            mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,script:Crypto.util.bytesToHex(cTx.outputs[0].script) ,vout: 0,status: Mempool.PENDING});
            if(isYours){
              mempool.addUTXO({id: futureTxid,path: yourPath,sats: nValue,vout: 1,script:Crypto.util.bytesToHex(cTx.outputs[1].script),status: Mempool.PENDING});
            }
          }else{
            if(isYours){
              mempool.addUTXO({id: futureTxid,path: yourPath,sats: nValue,vout: 0,script:Crypto.util.bytesToHex(cTx.outputs[0].script),status: Mempool.PENDING});
            }
          }
        }  
      } else {
        // Format the inputs how the Ledger SDK prefers
        const arrInputs = [];
        const arrAssociatedKeysets = [];
        for (const cInput of cTx.inputs) {
          const cInputFull = await getTxInfo(cInput.outpoint.hash);
          arrInputs.push([await cHardwareWallet.splitTransaction(cInputFull.hex), cInput.outpoint.index]);
          arrAssociatedKeysets.push(cInput.path);
        }
        const cLedgerTx = await cHardwareWallet.splitTransaction(cTx.serialize());
              const strOutputScriptHex = await cHardwareWallet
          .serializeTransactionOutputs(cLedgerTx)
          .toString("hex");

        // Sign the transaction via Ledger
        const strSerialisedTx = await confirmPopup(
          {
            title: ALERTS.CONFIRM_POPUP_TRANSACTION,
            html: createTxConfirmation(outputs),
            resolvePromise: cHardwareWallet.createPaymentTransactionNew({
              inputs: arrInputs,
              associatedKeysets: arrAssociatedKeysets,
              outputScriptHex: strOutputScriptHex,
            }),
          }
        );

       
        // Broadcast the Hardware (Ledger) TX
        const result= await sendTransaction(strSerialisedTx);
        if(result){
          for(const tx of cTx.inputs){
            mempool.autoRemoveUTXO({id: tx.outpoint.hash,path: tx.path,vout: tx.outpoint.index})
          }
         // Add our change (if any) to the local mempool
         const [isYours,yourPath]= await isYourAddress(address);
         const futureTxid=swapHEXEndian(await hash(Crypto.util.hexToBytes((await hash((Crypto.util.hexToBytes(strSerialisedTx)))))));
         
         if(nChange>0){
          mempool.addUTXO({id: futureTxid,path: changeAddressPath,sats: nChange,script:Crypto.util.bytesToHex(cTx.outputs[0].script) ,vout: 0,status: Mempool.PENDING});        
          if(isYours){
              mempool.addUTXO({id: futureTxid,path: yourPath,sats: nValue,vout: 1,script:Crypto.util.bytesToHex(cTx.outputs[1].script),status: Mempool.PENDING});
            }
         }else{
            if(isYours){
              mempool.addUTXO({id: futureTxid,path: yourPath,sats: nValue,vout: 0,script:Crypto.util.bytesToHex(cTx.outputs[0].script),status: Mempool.PENDING});
            }
         }
        }
      }
      domGenIt.innerHTML = "Continue";
    }

    
    function insert(arr, index, newItem) {
      // part of the array before the specified index
      return [...arr.slice(0, index),
          // inserted item
          newItem,
          // part of the array after the specified index
          ...arr.slice(index)
         ]
    }

    function addScriptLength(arrTxBytes, arrTxBytes, nInputLen) {
      let n_found = 0;
      const new_transaction_bytes = arrTxBytes;
      for (let i = 0; i < arrTxBytes.length; i++) {
        if (arrTxBytes[i + 1] === 71 || arrTxBytes[i + 1] === 72 || arrTxBytes[i + 1] === 73) {
          if (arrTxBytes[i + arrTxBytes[i]] === arrTxBytes[arrTxBytes.length - 1]){
            new_transaction_bytes[i]++;
            n_found++;
            if (n_found === nInputLen) {
              return new_transaction_bytes;
            }
          }
        }
      }
    }

    function findCompressedPubKey(arrTxBytes) {
      const arrToFind = [1, 33];
      for (let i = 0; i < arrTxBytes.length; i++) {
        if (arrTxBytes[i] === arrToFind[0]) {
          if (arrTxBytes[i + 1] === arrToFind[1]) {
             const compressedPubKey = [];
             for (let j = 0; j < 33; j++) {
              compressedPubKey.push(arrTxBytes[i + 2 + j]);
             }
             return compressedPubKey;
          }
        }
      }
    }

    function addExtraBytes(arrTxBytes, arrPubkeyBytes, nLen) {
      let arrNewTxBytes = [];
      let nFound = 0;
      for (let i = 0; i < arrTxBytes.length; i++) {
        arrNewTxBytes.push(arrTxBytes[i]);
        let fFound = true;

        if (nFound !== nLen) {
          for (let j = 0; j < arrPubkeyBytes.length; j++) {
            if (arrTxBytes[i + j] !== arrPubkeyBytes[j]) {
              fFound = false;
              break;
            }
          }

          if (fFound) {
            arrNewTxBytes = insert(arrNewTxBytes, arrNewTxBytes.length - 2, 0);
            nFound++;
          }
        }
      }
      return arrNewTxBytes;
    }

    async function createRawTransaction() {
      // Prepare a TX
      const cTx = bitjs.transaction();
      const txid = document.getElementById("prevTrxHash").value;
      const index = document.getElementById("index").value;
      const script = document.getElementById("script").value;

      // Primary input
      cTx.addinput({txid, index, script});

      // Primary output
      const strAddress = document.getElementById("address1").value;
      const nValue = document.getElementById("value1").value;
      cTx.addoutput(strAddress, nValue);

      // Change output
      const strChange = document.getElementById("address2").value;
      const nChangeValue = document.getElementById("value2").value;
      cTx.addoutput(strChange, nChangeValue);

      // Sign via WIF key
      const wif = document.getElementById("wif").value;
      document.getElementById("rawTrx").value = await cTx.sign(wif, 1); //SIGHASH_ALL DEFAULT 1
    }
    function addCellToTable(row,data){
      let td=row.insertCell();
      td.appendChild(document.createTextNode(data));
      td.style.border = '1px solid black';
    }
    async function openTab(evt, tabName) {
      // Hide all screens and deactivate link highlights
      for (const domScreen of arrDomScreens) domScreen.style.display = "none";
      for (const domLink of arrDomScreenLinks) domLink.classList.remove("active");

      // Show and activate the given screen
      document.getElementById(tabName).style.display = "block";
      evt.currentTarget.classList.add("active");
      
      // Close the navbar if it's not already closed
      if (!domNavbarToggler.className.includes("collapsed"))
        domNavbarToggler.click();
      
      if (tabName === "Governance") {
	updateGovernanceTab();
      }
      if (tabName==="Masternode") {
	updateMasternodeTab();
      }  
      
    }
  domStart.click();

  async function updateGovernanceTab() {
    const proposals= await Masternode.getProposals();
    domGovProposalsTableBody.innerHTML="";
    for (const proposal of proposals){
      if(proposal.RemainingPaymentCount === 0){
        continue;
      }
      const tr = domGovProposalsTableBody.insertRow();
      const td1 = tr.insertCell();
      // IMPORTANT: We must sanite all of our HTML or a rogue server or malicious proposal could perform a cross side scripting attack
      td1.innerHTML=`<a class="active" href="${sanitizeHTML(proposal.URL)}"><b>${sanitizeHTML(proposal.Name)}</b></a>`
      const td2 = tr.insertCell();
      td2.innerHTML=`<b>${sanitizeHTML(proposal.MonthlyPayment)}</b> ${cChainParams.current.TICKER} <br>
      <small> ${sanitizeHTML(proposal['RemainingPaymentCount'])} payments remaining of <b>${sanitizeHTML(proposal.TotalPayment)}</b> ${cChainParams.current.TICKER} total</small>`
      const td3 = tr.insertCell();
      let {Yeas, Nays} = proposal;
      Yeas = parseInt(Yeas);
      Nays = parseInt(Nays);
      const percentage = Yeas + Nays !== 0 ? (Yeas / (Yeas + Nays)) * 100 : 0;
      
      td3.innerHTML=`<b>${percentage.toFixed(2)}%</b> <br>
      <small> <b><div class="text-success" style="display:inline;"> ${Yeas} </div></b> /
	  <b><div class="text-danger" style="display:inline;"> ${Nays} </div></b>
      `;
      const td4 = tr.insertCell();
      //append vote buttons	  
      const buttonNo = document.createElement('button');
      buttonNo.className = "adonis-button-big";
      buttonNo.innerText="No";
      buttonNo.onclick = () => govVote(proposal.Hash, 2);
      
      const buttonYes = document.createElement('button');
      buttonYes.className = "adonis-button-big";
      buttonYes.innerText="Yes";
      buttonYes.onclick = () => govVote(proposal.Hash, 1);
      
      td4.appendChild(buttonNo)
      td4.appendChild(buttonYes)
    }
  }
  
  async function updateMasternodeTab() {
    //TODO: IN A FUTURE ADD MULTI-MASTERNODE SUPPORT BY SAVING MNs with which you logged in the past.
    // Ensure a wallet is loaded
    domMnTextErrors.innerHTML = "";
    domAccessMasternode.style.display = "none";
    domCreateMasternode.style.display = "none";
    domMnDashboard.style.display = "none";
    
    if (!masterKey) {
      domMnTextErrors.innerHTML = "Please " + (hasEncryptedWallet() ? "unlock" : "import") + " your <b>COLLATERAL WALLET</b> first.";
      return;
    }
    
    if (masterKey.isHardwareWallet) {
      domMnTxId.style.display = "none";
      domMnTextErrors.innerHTML = "Ledger is not yet supported";
      return;
    }

    if(!mempool.getConfirmed().length) {
      domMnTextErrors.innerHTML = "Your wallet is empty or still loading, re-open the tab in a few seconds!";
      return;
    }
    
    let strMasternodeJSON = localStorage.getItem("masternode");
    // If the collateral is missing (spent, or switched wallet) then remove the current MN
    if (strMasternodeJSON) {
      const cMasternode = JSON.parse(strMasternodeJSON);
      if (!mempool.getConfirmed().find(utxo => isMasternodeUTXO(utxo, cMasternode))) {
        localStorage.removeItem("masternode");
	strMasternodeJSON = null;
      }
    }
    
    domControlMasternode.style.display = strMasternodeJSON ? "block" : "none";
    
    // first case: the wallet is not HD and it is not hardware, so in case the wallet has collateral the user can check its status and do simple stuff like voting
    if (!masterKey.isHD) {
      domMnAccessMasternodeText.innerHTML = masternodeLegacyAccessText;
      domMnTxId.style.display = "none";
      // Find the first UTXO matching the expected collateral size
      const cCollaUTXO = mempool.getConfirmed().find(cUTXO => cUTXO.sats === cChainParams.current.collateralInSats);
      const balance = getBalance(false);
      if (cCollaUTXO) {
	if (strMasternodeJSON) {
	  const cMasternode = new Masternode(JSON.parse(localStorage.getItem("masternode")));
	  const cMasternodeData = await refreshMasternodeData(cMasternode);
	  domMnDashboard.style.display = "";
	} else {
	  domMnTxId.style.display = "none";
          domAccessMasternode.style.display = "block";
	}
      } else if (balance < cChainParams.current.collateralInSats) {
        // The user needs more funds
        domMnTextErrors.innerHTML = "You need <b>" + ((cChainParams.current.collateralInSats - balance) / COIN) + " more " + cChainParams.current.TICKER + "</b> to create a Masternode!";
      } else {
        // The user has the funds, but not an exact collateral, prompt for them to create one
        domCreateMasternode.style.display = "block";
        domMnTxId.style.display = "none";
        domMnTxId.innerHTML = "";
      }
    } else {
      domMnTxId.style.display = "none";
      domMnTxId.innerHTML = "";
      domMnAccessMasternodeText.innerHTML = masternodeHDAccessText;
      
      // First UTXO for each address in HD
      const mapCollateralAddresses = new Map();
      
      // Aggregate all valid Masternode collaterals into a map of Address <--> Collateral
      for (const cUTXO of mempool.getConfirmed()) {
        if (cUTXO.sats !== cChainParams.current.collateralInSats) continue;
        mapCollateralAddresses.set(cUTXO.path, cUTXO);
      }
      const fHasCollateral = mapCollateralAddresses.size > 0;
      
      // If there's no loaded MN, but valid collaterals, display the configuration screen
      if (!strMasternodeJSON && fHasCollateral) {
        domMnTxId.style.display = "block";
        domAccessMasternode.style.display = "block";
	
        for (const [key, value] of mapCollateralAddresses) {
          const option = document.createElement('option');
          option.value = key;
          option.innerText = await masterKey.getAddress(key);
          domMnTxId.appendChild(option);
        }
      }
      
      // If there's no collateral found, display the creation UI
      if (!fHasCollateral) domCreateMasternode.style.display = "block";
      
      // If we have a collateral and a loaded Masternode, display the Dashboard
      if (fHasCollateral && strMasternodeJSON) {
        const cMasternode = new Masternode(JSON.parse(strMasternodeJSON));
        // Refresh the display
        refreshMasternodeData(cMasternode);
        domMnDashboard.style.display = "";
      }
    }
  }
  
  async function refreshMasternodeData(cMasternode, fAlert = false) {
    const cMasternodeData = await cMasternode.getFullData();
    if (debug) console.log(cMasternodeData);

    // If we have MN data available, update the dashboard
    if (cMasternodeData && cMasternodeData.status !== "MISSING") {
      domMnTextErrors.innerHTML = "";
      domMnProtocol.innerText = `(${sanitizeHTML(cMasternodeData.version)})`;
      domMnStatus.innerText = sanitizeHTML(cMasternodeData.status);
      domMnNetType.innerText = sanitizeHTML(cMasternodeData.network.toUpperCase());
      domMnNetIP.innerText = cMasternode.addr;
      domMnLastSeen.innerText = new Date(cMasternodeData.lastseen * 1000).toLocaleTimeString();
    }

    if (cMasternodeData.status === "MISSING") {
      domMnTextErrors.innerHTML = "Masternode is currently <b>OFFLINE</b>";
      createAlert('warning', 'Your masternode is offline, we will try to start it', 6000);
      // try to start the masternode
      const started = await cMasternode.start();
      if (started) {
        domMnTextErrors.innerHTML = "Masternode successfully started!";
        createAlert('success', 'Masternode successfully started!, it will be soon online', 6000);
        localStorage.setItem("masternode", JSON.stringify(cMasternode));
      } else {
        domMnTextErrors.innerHTML = "We couldn't start your masternode";
        createAlert('warning', 'We could not start your masternode', 6000);
      }
    } else if (cMasternodeData.status === "ENABLED" || cMasternodeData.status === "PRE_ENABLED") {
      if (fAlert) createAlert('success', `Your masternode status is <b> ${sanitizeHTML(cMasternodeData.status)} </b>`, 6000);
      localStorage.setItem("masternode", JSON.stringify(cMasternode));
    } else if (cMasternodeData.status === "REMOVED") {
      domMnTextErrors.innerHTML = "Masternode is currently <b>REMOVED</b>";
      if (fAlert) createAlert('warning', 'Your masternode is in <b>REMOVED</b> state', 6000);
    } else { // connection problem
      domMnTextErrors.innerHTML = "Unable to connect!";
      if (fAlert) createAlert('warning', 'Unable to connect!', 6000);
    }

    // Return the data in case the caller needs additional context
    return cMasternodeData;
  }

    function refreshChainData() {
      // If in offline mode: don't sync ANY data or connect to the internet
      if (!networkEnabled) return console.warn("Offline mode active: For your security, the wallet will avoid ALL internet requests.");
      if (!masterKey) return;

      // Play reload anim
      domBalanceReload.classList.add("playAnim");
      domBalanceReloadStaking.classList.add("playAnim");

      // Fetch block count + UTXOs
      getBlockCount();
    }

    // A safety mechanism enabled if the user attempts to leave without encrypting/saving their keys
    const beforeUnloadListener = (evt) => {
      evt.preventDefault();
      // Disable Save your wallet warning on unload
      if( !cChainParams.current.isTestnet ) createAlert("warning", ALERTS.SAVE_WALLET_PLEASE, [], 10000);
      // Most browsers ignore this nowadays, but still, keep it 'just incase'
      return evt.returnValue = BACKUP_OR_ENCRYPT_WALLET;
    };

    window.onload = (() => {
      // Configure Identicon
      jdenticon.configure();

      // Customise the UI if a saved wallet exists
      if (hasEncryptedWallet()) {
        // Hide the 'Generate wallet' buttons
        domGenerateWallet.style.display = "none";
        domGenVanityWallet.style.display = "none";

        // Display the password unlock upfront
        accessOrImportWallet();
      }

      // Payment processor redirect
      if (requestTo && requestAmount) {
        guiPreparePayment(requestTo, requestAmount, urlParams.has('desc') ? urlParams.get('desc') : "");
      }


    });

    setInterval(refreshChainData, 15000);
    domPrefix.value = ""
    domPrefixNetwork.innerText = cChainParams.current.PUBKEY_PREFIX.join(' or ');
  </script>

</body>

<!-- Load complex backend-level components last -->
<script type="text/javascript" src="scripts/libs/aes-gcm.js"></script>
<script type="text/javascript" src="scripts/libs/crypto-min.js"></script>
<script type="text/javascript" src="scripts/libs/crypto-sha256.js"></script>
<script type="text/javascript" src="scripts/libs/crypto-sha256-hmac.js"></script>
<script type="text/javascript" src="scripts/libs/ripemd160.js"></script>
<script type="text/javascript" src="scripts/libs/jsbn.js"></script>
<script type="text/javascript" src="scripts/libs/script.js"></script>
<script type="text/javascript" src="scripts/libs/qrcode.js"></script>
<script type="text/javascript" src="scripts/libs/sha256.js"></script>
<script type="text/javascript" src="scripts/libs/bn.js"></script>
<script type="text/javascript" src="scripts/libs/noble-secp256k1.js"></script>
<script type="text/javascript" src="scripts/bitTrx.js"></script>
<script type="text/javascript" src="scripts/libs/ledger.js"></script>
<script type="text/javascript" src="scripts/libs/bip39.js"></script>
<script type="text/javascript" src="scripts/masternode.js"></script>

</html>
